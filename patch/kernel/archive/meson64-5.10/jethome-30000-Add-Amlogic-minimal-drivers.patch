diff -urN linux-5.10.y-a/drivers/amlogic/bluetooth/bt_device.c linux-5.10.y-b/drivers/amlogic/bluetooth/bt_device.c
--- linux-5.10.y-a/drivers/amlogic/bluetooth/bt_device.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/drivers/amlogic/bluetooth/bt_device.c	2022-11-27 09:30:02.000000000 +0800
@@ -0,0 +1,749 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * drivers/amlogic/bluetooth/bt_device.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <linux/leds.h>
+#include <linux/gpio.h>
+#include <linux/rfkill.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/of_gpio.h>
+#include <linux/amlogic/cpu_version.h>
+#include <linux/amlogic/iomap.h>
+#include <linux/io.h>
+#include <linux/amlogic/bt_device.h>
+#include <linux/amlogic/pm.h>
+#include <linux/amlogic/wifi_dt.h>
+#include <linux/random.h>
+#ifdef CONFIG_AM_WIFI_SD_MMC
+#include <linux/amlogic/wifi_dt.h>
+#endif
+#include "../../gpio/gpiolib.h"
+
+#include <linux/interrupt.h>
+#include <linux/pm_wakeup.h>
+#include <linux/pm_wakeirq.h>
+#include <linux/irq.h>
+
+#include <linux/input.h>
+
+#if defined(CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND) && defined(CONFIG_AMLOGIC_GX_SUSPEND)
+#include <linux/amlogic/pm.h>
+static struct early_suspend bt_early_suspend;
+#endif
+
+#define BT_RFKILL "bt_rfkill"
+#define MODULE_ID 0x271
+#define POWER_EVENT_DEF     0
+#define POWER_EVENT_RESET   1
+#define POWER_EVENT_EN      2
+
+char bt_addr[18] = "";
+char *btmac;
+core_param(btmac, btmac, charp, 0644);
+static struct class *bt_addr_class;
+static int btwake_evt;
+static int btirq_flag;
+static int btpower_evt;
+static int flag_n;
+static int flag_p;
+static int cnt;
+static int rfk_reg = 1;
+
+static int distinguish_module(void)
+{
+	// !!!!!FIXME int vendor_id = 0;
+
+	//vendor_id = sdio_get_vendor();
+
+	//if (vendor_id == MODULE_ID)
+		return 0;
+
+	//return 1;
+}
+
+static ssize_t value_show(struct class *cls,
+	struct class_attribute *attr, char *_buf)
+{
+	char local_addr[6];
+
+	if (!_buf)
+		return -EINVAL;
+
+	if (strlen(bt_addr) == 0) {
+		local_addr[0] = 0x22;
+		local_addr[1] = 0x22;
+		local_addr[2] = prandom_u32();
+		local_addr[3] = prandom_u32();
+		local_addr[4] = prandom_u32();
+		local_addr[5] = prandom_u32();
+		sprintf(bt_addr, "%02x:%02x:%02x:%02x:%02x:%02x",
+		local_addr[0], local_addr[1], local_addr[2],
+		local_addr[3], local_addr[4], local_addr[5]);
+	}
+
+	return sprintf(_buf, "%s\n", bt_addr);
+}
+
+static ssize_t value_store(struct class *cls,
+			   struct class_attribute *attr,
+			   const char __user *buf, size_t count)
+{
+	int ret = -EINVAL;
+
+	if (!buf)
+		return ret;
+
+	snprintf(bt_addr, sizeof(bt_addr), "%s", buf);
+
+	if (bt_addr[strlen(bt_addr) - 1] == '\n')
+		bt_addr[strlen(bt_addr) - 1] = '\0';
+
+	pr_info("bt_addr=%s\n", bt_addr);
+	return count;
+}
+static CLASS_ATTR_RW(value);
+
+struct bt_dev_runtime_data {
+	struct rfkill *bt_rfk;
+	struct bt_dev_data *pdata;
+};
+
+static void off_def_power(struct bt_dev_data *pdata, unsigned long down_time)
+{
+	if (pdata->gpio_reset > 0) {
+		if (pdata->power_on_pin_OD &&
+			pdata->power_low_level) {
+			gpio_direction_input(pdata->gpio_reset);
+		} else {
+			gpio_direction_output(pdata->gpio_reset,
+				pdata->power_low_level);
+		}
+
+		if (down_time)
+			msleep(down_time);
+	}
+
+	if (pdata->gpio_en > 0) {
+		if (pdata->power_on_pin_OD &&
+			pdata->power_low_level) {
+			gpio_direction_input(pdata->gpio_en);
+		} else {
+			set_usb_bt_power(0);
+		}
+	}
+}
+
+static void on_def_power(struct bt_dev_data *pdata, unsigned long up_time)
+{
+	if (pdata->gpio_reset > 0) {
+		if (pdata->power_on_pin_OD &&
+			!pdata->power_low_level) {
+			gpio_direction_input(pdata->gpio_reset);
+		} else {
+			gpio_direction_output(pdata->gpio_reset,
+				!pdata->power_low_level);
+		}
+
+		if (up_time)
+			msleep(up_time);
+	}
+
+	if (pdata->gpio_en > 0) {
+		if (pdata->power_on_pin_OD &&
+			!pdata->power_low_level) {
+			gpio_direction_input(pdata->gpio_en);
+		} else {
+			set_usb_bt_power(1);
+		}
+	}
+}
+
+static void off_reset_power(struct bt_dev_data *pdata, unsigned long down_time)
+{
+	if (pdata->gpio_reset > 0) {
+		if (pdata->power_on_pin_OD &&
+			pdata->power_low_level) {
+			gpio_direction_input(pdata->gpio_reset);
+		} else {
+			gpio_direction_output(pdata->gpio_reset,
+				pdata->power_low_level);
+		}
+
+		if (down_time)
+			msleep(down_time);
+	}
+}
+
+static void on_reset_power(struct bt_dev_data *pdata, unsigned long up_time)
+{
+	if (pdata->gpio_reset > 0) {
+		if (pdata->power_on_pin_OD &&
+			!pdata->power_low_level) {
+			gpio_direction_input(pdata->gpio_reset);
+		} else {
+			gpio_direction_output(pdata->gpio_reset,
+				!pdata->power_low_level);
+		}
+
+		if (up_time)
+			msleep(up_time);
+	}
+}
+
+static void bt_device_off(struct bt_dev_data *pdata)
+{
+	if (!distinguish_module())
+		return;
+
+	if (pdata->power_down_disable == 0) {
+		switch (btpower_evt) {
+		case POWER_EVENT_DEF:
+			off_def_power(pdata, 0);
+			break;
+		case POWER_EVENT_RESET:
+			off_reset_power(pdata, 0);
+			break;
+		case POWER_EVENT_EN:
+			set_usb_bt_power(0);
+			break;
+		default:
+			pr_err("%s default no electricity", __func__);
+			break;
+		}
+		msleep(20);
+	}
+}
+
+static void bt_device_init(struct bt_dev_data *pdata)
+{
+	int tmp = 0;
+	btpower_evt = 0;
+	btirq_flag = 0;
+
+	if (pdata->gpio_reset > 0)
+		gpio_request(pdata->gpio_reset, BT_RFKILL);
+
+	if (pdata->gpio_en > 0)
+		gpio_request(pdata->gpio_en, BT_RFKILL);
+
+	if (pdata->gpio_hostwake > 0) {
+		gpio_request(pdata->gpio_hostwake, BT_RFKILL);
+		gpio_direction_output(pdata->gpio_hostwake, 1);
+	}
+
+	if (pdata->gpio_btwakeup > 0) {
+		gpio_request(pdata->gpio_btwakeup, BT_RFKILL);
+		gpio_direction_input(pdata->gpio_btwakeup);
+	}
+
+	tmp = pdata->power_down_disable;
+	pdata->power_down_disable = 0;
+	bt_device_off(pdata);
+	pdata->power_down_disable = tmp;
+}
+
+static void bt_device_deinit(struct bt_dev_data *pdata)
+{
+	if (pdata->gpio_reset > 0)
+		gpio_free(pdata->gpio_reset);
+
+	if (pdata->gpio_en > 0)
+		gpio_free(pdata->gpio_en);
+
+	btpower_evt = 0;
+	if (pdata->gpio_hostwake > 0)
+		gpio_free(pdata->gpio_hostwake);
+}
+
+static void bt_device_on(struct bt_dev_data *pdata, unsigned long down_time, unsigned long up_time)
+{
+	if (pdata->power_down_disable == 0) {
+		switch (btpower_evt) {
+		case POWER_EVENT_DEF:
+			off_def_power(pdata, down_time);
+			on_def_power(pdata, up_time);
+			break;
+		case POWER_EVENT_RESET:
+			off_reset_power(pdata, down_time);
+			on_reset_power(pdata, up_time);
+			break;
+		case POWER_EVENT_EN:
+			set_usb_bt_power(0);
+			set_usb_bt_power(1);
+			break;
+		default:
+			pr_err("%s default no electricity", __func__);
+			break;
+		}
+	}
+}
+
+/*The system calls this function when GPIOC_14 interrupt occurs*/
+static irqreturn_t bt_interrupt(int irq, void *dev_id)
+{
+	struct bt_dev_data *pdata = (struct bt_dev_data *)dev_id;
+
+	if (btirq_flag == 1) {
+		schedule_work(&pdata->btwakeup_work);
+		pr_info("freeze: test BT IRQ\n");
+	}
+
+	return IRQ_HANDLED;
+}
+
+static enum hrtimer_restart btwakeup_timer_handler(struct hrtimer *timer)
+{
+	struct bt_dev_data *pdata  = container_of(timer,
+			struct bt_dev_data, timer);
+
+	if  (!gpio_get_value(pdata->gpio_btwakeup) && cnt  < 5)
+		cnt++;
+	if (cnt >= 5 && cnt < 15) {
+		if (gpio_get_value(pdata->gpio_btwakeup))
+			flag_p++;
+		else if (!gpio_get_value(pdata->gpio_btwakeup))
+			flag_n++;
+		cnt++;
+	}
+	pr_info("%s power: %d,netflix:%d\n", __func__, flag_p, flag_n);
+	if (flag_p >= 7) {
+		pr_info("%s power: %d\n", __func__, flag_p);
+		btwake_evt = 2;
+		cnt = 0;
+		flag_p = 0;
+		btirq_flag = 0;
+		input_event(pdata->input_dev,
+			EV_KEY, KEY_POWER, 1);
+		input_sync(pdata->input_dev);
+		input_event(pdata->input_dev,
+			EV_KEY, KEY_POWER, 0);
+		input_sync(pdata->input_dev);
+	} else if (flag_n >= 7) {
+		pr_info("%s netflix: %d\n", __func__, flag_n);
+		btwake_evt = 2;
+		cnt = 0;
+		flag_n = 0;
+		btirq_flag = 0;
+		input_event(pdata->input_dev, EV_KEY, 133, 1);
+		input_sync(pdata->input_dev);
+		input_event(pdata->input_dev, EV_KEY, 133, 0);
+		input_sync(pdata->input_dev);
+	}
+	if (btwake_evt != 2 && cnt != 0)
+		hrtimer_start(&pdata->timer,
+			ktime_set(0, 20 * 1000000), HRTIMER_MODE_REL);
+	return HRTIMER_NORESTART;
+}
+
+static void get_btwakeup_irq_work(struct work_struct *work)
+{
+	struct bt_dev_data *pdata  = container_of(work,
+		struct bt_dev_data, btwakeup_work);
+
+	if (btwake_evt == 2)
+		return;
+	pr_info("%s", __func__);
+	hrtimer_start(&pdata->timer,
+			ktime_set(0, 100 * 1000000), HRTIMER_MODE_REL);
+}
+
+static int bt_set_block(void *data, bool blocked)
+{
+	struct bt_dev_data *pdata = data;
+
+	if (rfk_reg) {
+		pr_info("first rfkill_register skip\n");
+		rfk_reg = 0;
+		return 0;
+	}
+
+	pr_info("BT_RADIO going: %s\n", blocked ? "off" : "on");
+
+	if (!blocked) {
+		pr_info("AML_BT: going ON,btpower_evt=%d\n", btpower_evt);
+		bt_device_on(pdata, 200, 200);
+	} else {
+		pr_info("AML_BT: going OFF,btpower_evt=%d\n", btpower_evt);
+		bt_device_off(pdata);
+	}
+	return 0;
+}
+
+static const struct rfkill_ops bt_rfkill_ops = {
+	.set_block = bt_set_block,
+};
+
+#if defined(CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND) && defined(CONFIG_AMLOGIC_GX_SUSPEND)
+static void bt_earlysuspend(struct early_suspend *h)
+{
+}
+
+static void bt_lateresume(struct early_suspend *h)
+{
+}
+#endif
+
+static int bt_suspend(struct platform_device *pdev,
+		      pm_message_t state)
+{
+	struct bt_dev_runtime_data *prdata = platform_get_drvdata(pdev);
+	btwake_evt = 0;
+	pr_info("bt suspend\n");
+	disable_irq(prdata->pdata->irqno_wakeup);
+
+	return 0;
+}
+
+static int bt_resume(struct platform_device *pdev)
+{
+	struct bt_dev_runtime_data *prdata = platform_get_drvdata(pdev);
+	pr_info("bt resume\n");
+	enable_irq(prdata->pdata->irqno_wakeup);
+	btwake_evt = 0;
+/* !!!!!!FIXME
+	if ((get_resume_method() == RTC_WAKEUP) ||
+		(get_resume_method() == AUTO_WAKEUP)) {
+		btwake_evt = 1;
+		btirq_flag = 1;
+	    flag_n = 0;
+		flag_p = 0;
+		cnt = 0;
+	}
+	if (distinguish_module() && get_resume_method() == BT_WAKEUP) {
+		input_event(prdata->pdata->input_dev,
+			EV_KEY, KEY_POWER, 1);
+		input_sync(prdata->pdata->input_dev);
+		input_event(prdata->pdata->input_dev,
+			EV_KEY, KEY_POWER, 0);
+		input_sync(prdata->pdata->input_dev);
+	}
+*/
+	return 0;
+}
+
+static int bt_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	const void *prop;
+	struct rfkill *bt_rfk;
+	struct bt_dev_data *pdata = NULL;
+	struct bt_dev_runtime_data *prdata;
+	struct input_dev *input_dev;
+
+#ifdef CONFIG_OF
+	if (pdev && pdev->dev.of_node) {
+		const char *str;
+		//struct gpio_desc *desc;
+
+		pr_debug("enter %s of_node\n", __func__);
+		pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+		if (!pdata) {
+			ret = -ENOMEM;
+			goto err_res;
+		}
+
+		ret = of_property_read_string(pdev->dev.of_node,
+					      "reset-gpios", &str);
+		if (ret) {
+			pr_warn("not get gpio_reset\n");
+			pdata->gpio_reset = 0;
+		} else {
+			pdata->gpio_reset = of_get_named_gpio_flags
+							(pdev->dev.of_node,
+							"reset-gpios", 0, NULL);
+		}
+
+		ret = of_property_read_string(pdev->dev.of_node,
+					      "bt_en-gpios", &str);
+		if (ret) {
+			pr_warn("not get gpio_en\n");
+			pdata->gpio_en = 0;
+		} else {
+			pdata->gpio_en = of_get_named_gpio_flags
+							(pdev->dev.of_node,
+							"bt_en-gpios", 0, NULL);
+		}
+		ret = of_property_read_string(pdev->dev.of_node,
+					      "hostwake-gpios", &str);
+		if (ret) {
+			pr_warn("not get gpio_hostwake\n");
+			pdata->gpio_hostwake = 0;
+		} else {
+			pdata->gpio_hostwake = of_get_named_gpio_flags
+							(pdev->dev.of_node,
+							"hostwake-gpios",
+							0, NULL);
+		}
+		/*gpio_btwakeup = BT_WAKE_HOST*/
+		ret = of_property_read_string(pdev->dev.of_node,
+			"btwakeup-gpios", &str);
+		if (ret) {
+			pr_warn("not get btwakeup-gpios\n");
+			pdata->gpio_btwakeup = 0;
+		} else {
+			pdata->gpio_btwakeup = of_get_named_gpio_flags
+							(pdev->dev.of_node,
+							"btwakeup-gpios",
+							0, NULL);
+		}
+
+		prop = of_get_property(pdev->dev.of_node,
+				       "power_low_level", NULL);
+		if (prop) {
+			pr_debug("power on valid level is low");
+			pdata->power_low_level = 1;
+		} else {
+			pr_debug("power on valid level is high");
+			pdata->power_low_level = 0;
+			pdata->power_on_pin_OD = 0;
+		}
+		ret = of_property_read_u32(pdev->dev.of_node,
+					   "power_on_pin_OD",
+					   &pdata->power_on_pin_OD);
+		if (ret)
+			pdata->power_on_pin_OD = 0;
+		pr_debug("bt: power_on_pin_OD = %d;\n", pdata->power_on_pin_OD);
+		ret = of_property_read_u32(pdev->dev.of_node,
+					   "power_off_flag",
+					   &pdata->power_off_flag);
+		if (ret)
+			pdata->power_off_flag = 1;/*bt poweroff*/
+		pr_debug("bt: power_off_flag = %d;\n", pdata->power_off_flag);
+
+		ret = of_property_read_u32(pdev->dev.of_node,
+					   "power_down_disable",
+					   &pdata->power_down_disable);
+		if (ret)
+			pdata->power_down_disable = 0;
+		pr_debug("dis power down = %d;\n", pdata->power_down_disable);
+	} else if (pdev) {
+		pdata = (struct bt_dev_data *)(pdev->dev.platform_data);
+	} else {
+		ret = -ENOENT;
+		goto err_res;
+	}
+#else
+	pdata = (struct bt_dev_data *)(pdev->dev.platform_data);
+#endif
+	bt_addr_class = class_create(THIS_MODULE, "bt_addr");
+	ret = class_create_file(bt_addr_class, &class_attr_value);
+
+	bt_device_init(pdata);
+
+	if (pdata->power_down_disable == 1) {
+		pdata->power_down_disable = 0;
+		bt_device_on(pdata, 100, 0);
+		pdata->power_down_disable = 1;
+	}
+
+	/* default to bluetooth off */
+	/* rfkill_switch_all(RFKILL_TYPE_BLUETOOTH, 1); */
+	/* bt_device_off(pdata); */
+
+	bt_rfk = rfkill_alloc("bt-dev", &pdev->dev,
+			      RFKILL_TYPE_BLUETOOTH,
+			      &bt_rfkill_ops, pdata);
+
+	if (!bt_rfk) {
+		pr_info("rfk alloc fail\n");
+		ret = -ENOMEM;
+		goto err_rfk_alloc;
+	}
+
+	rfkill_init_sw_state(bt_rfk, true);
+	ret = rfkill_register(bt_rfk);
+	if (ret) {
+		pr_err("rfkill_register fail\n");
+		goto err_rfkill;
+	}
+	prdata = kmalloc(sizeof(*prdata), GFP_KERNEL);
+
+	if (!prdata)
+		goto err_rfkill;
+
+	prdata->bt_rfk = bt_rfk;
+	prdata->pdata = pdata;
+	platform_set_drvdata(pdev, prdata);
+#if defined(CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND) && defined(CONFIG_AMLOGIC_GX_SUSPEND)
+	bt_early_suspend.level =
+		EARLY_SUSPEND_LEVEL_DISABLE_FB;
+	bt_early_suspend.suspend = bt_earlysuspend;
+	bt_early_suspend.resume = bt_lateresume;
+	bt_early_suspend.param = pdev;
+	register_early_suspend(&bt_early_suspend);
+#endif
+
+	/*1.Set BT_WAKE_HOST to the input state;*/
+	/*2.Get interrupt number(irqno_wakeup).*/
+	pdata->irqno_wakeup = gpio_to_irq(pdata->gpio_btwakeup);
+
+	/*Register interrupt service function*/
+	ret = request_irq(pdata->irqno_wakeup, bt_interrupt,
+			IRQF_TRIGGER_FALLING, "bt-irq", (void *)pdata);
+	if (ret < 0)
+		pr_err("request_irq error ret=%d\n", ret);
+
+	//disable_irq(pdata->irqno_wakeup);
+
+	ret = device_init_wakeup(&pdev->dev, 1);
+	if (ret)
+		pr_err("device_init_wakeup failed: %d\n", ret);
+	/*Wake up the interrupt*/
+	ret = dev_pm_set_wake_irq(&pdev->dev, pdata->irqno_wakeup);
+	if (ret)
+		pr_err("dev_pm_set_wake_irq failed: %d\n", ret);
+
+	INIT_WORK(&pdata->btwakeup_work, get_btwakeup_irq_work);
+
+	//input
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		pr_err("[abner test]input_allocate_device failed: %d\n", ret);
+		return -EINVAL;
+	}
+	set_bit(EV_KEY,  input_dev->evbit);
+	set_bit(KEY_POWER, input_dev->keybit);
+	set_bit(133, input_dev->keybit);
+
+	input_dev->name = "input_btrcu";
+	input_dev->phys = "input_btrcu/input0";
+	input_dev->dev.parent = &pdev->dev;
+	input_dev->id.bustype = BUS_ISA;
+	input_dev->id.vendor = 0x0001;
+	input_dev->id.product = 0x0001;
+	input_dev->id.version = 0x0100;
+	input_dev->rep[REP_DELAY] = 0xffffffff;
+	input_dev->rep[REP_PERIOD] = 0xffffffff;
+	input_dev->keycodesize = sizeof(unsigned short);
+	input_dev->keycodemax = 0x1ff;
+	ret = input_register_device(input_dev);
+	if (ret < 0) {
+		pr_err("[abner test]input_register_device failed: %d\n", ret);
+		input_free_device(input_dev);
+		return -EINVAL;
+	}
+	pdata->input_dev = input_dev;
+
+	hrtimer_init(&pdata->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	pdata->timer.function = btwakeup_timer_handler;
+
+	return 0;
+
+err_rfkill:
+	rfkill_destroy(bt_rfk);
+err_rfk_alloc:
+	bt_device_deinit(pdata);
+err_res:
+	return ret;
+}
+
+static int bt_remove(struct platform_device *pdev)
+{
+	struct bt_dev_runtime_data *prdata =
+		platform_get_drvdata(pdev);
+	struct rfkill *rfk = NULL;
+	struct bt_dev_data *pdata = NULL;
+
+	platform_set_drvdata(pdev, NULL);
+
+	if (prdata) {
+		rfk = prdata->bt_rfk;
+		pdata = prdata->pdata;
+	}
+
+	if (pdata) {
+		bt_device_deinit(pdata);
+		kfree(pdata);
+	}
+
+	if (rfk) {
+		(rfk);
+		rfkill_destroy(rfk);
+	}
+	rfk = NULL;
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id bt_dev_dt_match[] = {
+	{	.compatible = "amlogic, aml-bt",
+	},
+	{},
+};
+#else
+#define bt_dev_dt_match NULL
+#endif
+
+static struct platform_driver bt_driver = {
+	.driver		= {
+		.name	= "aml_bt",
+		.of_match_table = bt_dev_dt_match,
+	},
+	.probe		= bt_probe,
+	.remove		= bt_remove,
+	.suspend	= bt_suspend,
+	.resume		= bt_resume,
+};
+
+static int __init bt_init(void)
+{
+	pr_info("amlogic rfkill init\n");
+
+	return platform_driver_register(&bt_driver);
+}
+
+static void __exit bt_exit(void)
+{
+	platform_driver_unregister(&bt_driver);
+}
+
+module_param(btpower_evt, int, 0664);
+MODULE_PARM_DESC(btpower_evt, "btpower_evt");
+
+module_param(btwake_evt, int, 0664);
+MODULE_PARM_DESC(btwake_evt, "btwake_evt");
+module_init(bt_init);
+module_exit(bt_exit);
+MODULE_DESCRIPTION("bt rfkill");
+MODULE_AUTHOR("");
+MODULE_LICENSE("GPL");
+
+/**************** bt mac *****************/
+
+static int __init mac_addr_set(char *line)
+{
+	if (line) {
+		pr_info("try to read bt mac from emmc key!\n");
+		strncpy(bt_addr, line, sizeof(bt_addr) - 1);
+		bt_addr[sizeof(bt_addr) - 1] = '\0';
+		btmac = (char *)bt_addr;
+	}
+
+	return 1;
+}
+
+__setup("mac_bt=", mac_addr_set);
+
diff -urN linux-5.10.y-a/drivers/amlogic/bluetooth/Kconfig linux-5.10.y-b/drivers/amlogic/bluetooth/Kconfig
--- linux-5.10.y-a/drivers/amlogic/bluetooth/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/drivers/amlogic/bluetooth/Kconfig	2022-11-27 09:30:04.000000000 +0800
@@ -0,0 +1,8 @@
+# Amlogic Bluetooth
+
+config AMLOGIC_BT_DEVICE
+    bool "BT Device support"
+    depends on BT && RFKILL
+    default y
+    help
+      Say Y here if you want to use the BT device.
diff -urN linux-5.10.y-a/drivers/amlogic/bluetooth/Makefile linux-5.10.y-b/drivers/amlogic/bluetooth/Makefile
--- linux-5.10.y-a/drivers/amlogic/bluetooth/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/drivers/amlogic/bluetooth/Makefile	2022-12-21 11:29:48.000000000 +0800
@@ -0,0 +1 @@
+#obj-$(CONFIG_AMLOGIC_BT_DEVICE) += bt_device.o
diff -urN linux-5.10.y-a/drivers/amlogic/Kconfig linux-5.10.y-b/drivers/amlogic/Kconfig
--- linux-5.10.y-a/drivers/amlogic/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/drivers/amlogic/Kconfig	2022-11-27 09:30:04.000000000 +0800
@@ -0,0 +1,171 @@
+config AMLOGIC_GKI
+	bool "Amlogic GKI macro"
+	default n
+	help
+		This macro controls GKI module build behavior, if enabled
+		some internal code will be build as external module
+
+config AMLOGIC_MODIFY
+	bool "Amlogic modify for kernel code"
+	default y
+	help
+		This option is set up for AMLOGIC modify of standard
+		kernel source code. All modify of kernel standard code
+		should be wrapped by this config
+
+config AMLOGIC_ANDROIDP
+	bool "Amlogic modify kernel in project androidp"
+	default n
+	help
+		This option is set up for AMLOGIC modify of standard
+		kernel source code in project androidp.
+
+config AMLOGIC_REMOVE_OLD
+	bool "Amlogic remove old soc code for g12a previous"
+	default n
+	help
+		This option is set up for removing code for G12A
+		previous.All modify of not used code should be
+		wrapped by this config
+
+config AMLOGIC_ARMV8_AARCH64
+	bool "AARCH64 kernel support for Amlogic ARMv8 Soc"
+	depends on AMLOGIC_MODIFY || COMPILE_TEST
+	default y
+	help
+	  aarch32 and aarch64 kernels are supported for armv8 socs.
+	  enable this config to select 64 bit kernel.
+	  Select Y if doult.
+
+config AMLOGIC_DRIVER
+	bool "Amlogic Peripheral drivers"
+	depends on AMLOGIC_MODIFY
+	default y
+	help
+		this option is provided for control amlogic
+		drivers, if you want to use amlogic driver
+		please open it.
+		Note: All amlogic driver should be placed in
+		this directory
+
+config AMLOGIC_ALLYESCONFIG
+	bool "Amlogic compile config option"
+	default n
+	help
+		This option is set up for masking frame size
+		limit in drivers/Makefile file. When we compile
+		kernel with --allyesconfig, we not limit the
+		frame size.
+
+config AMLOGIC_MEDIA_V4L_DEC
+	bool "enable amlogic v4l decode module."
+	default n
+	help
+		Support v4L protocol based decoding components.
+		Decoding is done by AmLogic hardware, and if you
+		need to support this feature, you need to enable
+		this configuration item.
+
+
+#
+# Amlogic DVB configuration
+#
+
+menu "Amlogic dvb configuration"
+
+config AMLOGIC_DVB
+	tristate "Amlogic dvb support"
+	depends on DVB_CORE && AMLOGIC_DVB_COMPAT
+	default n
+	help
+		This option is used only to control the
+		compilation of dvb related driver code, for
+		example hw_demux, it is enabled by default,
+		When it is turned on,it will automatically
+		select DVB_CORE and AMLOGIC_DVB_COMPAT.
+
+config AMLOGIC_DVB_COMPAT
+	tristate "Compat amlogic dvb"
+	depends on DVB_CORE
+	default n
+	help
+		This option is used only to compatible with
+		amlogic dvb related code, for example dvb-core,
+		it is enabled by default,depending on
+		AMLOGIC_DVB and DVB_CORE.
+
+config AMLOGIC_MFD
+	tristate "Compat amlogic mfd"
+	default n
+	help
+		This option is used only to compatible with
+		amlogic dvb related code,it is enabled by
+		default,depending on
+		AMLOGIC_MFD.
+
+config AMLOGIC_REGULATOR
+	tristate "Compat amlogic mfd"
+	default n
+	help
+		This option is used only to compatible with
+		amlogic mfd related code,it is enabled
+		by default,depending on
+		AMLOGIC_REGULATOR.
+
+endmenu
+
+if AMLOGIC_DRIVER
+menu "Amlogic Device Drivers"
+# Please add folders in alphabetical order
+
+#source "drivers/amlogic/algorithm/Kconfig"
+#source "drivers/amlogic/cpufreq/Kconfig"
+#source "drivers/amlogic/efuse_unifykey/Kconfig"
+#source "drivers/amlogic/ddr_tool/Kconfig"
+#source "drivers/amlogic/crypto/Kconfig"
+#source "drivers/amlogic/secmon/Kconfig"
+#source "drivers/amlogic/mailbox/Kconfig"
+#source "drivers/amlogic/reg_access/Kconfig"
+#source "drivers/amlogic/media/Kconfig"
+#source "drivers/amlogic/pci/Kconfig"
+#source "drivers/amlogic/thermal/Kconfig"
+#source "drivers/amlogic/clk_debug/Kconfig"
+#source "drivers/amlogic/input/Kconfig"
+#source "drivers/amlogic/tee/Kconfig"
+#source "drivers/amlogic/jtag/Kconfig"
+#source "drivers/amlogic/reboot/Kconfig"
+#source "drivers/amlogic/gki_tool/Kconfig"
+#source "drivers/amlogic/hifi4dsp/Kconfig"
+#source "drivers/amlogic/dvb/Kconfig"
+#source "drivers/amlogic/drm/Kconfig"
+#source "drivers/amlogic/irblaster/Kconfig"
+
+#source "drivers/amlogic/cpuidle/Kconfig"
+#source "drivers/amlogic/defendkey/Kconfig"
+#source "drivers/amlogic/free_reserved/Kconfig"
+#source "drivers/amlogic/usb/Kconfig"
+#source "drivers/amlogic/pm/Kconfig"
+#source "drivers/amlogic/power/Kconfig"
+#source "drivers/amlogic/debug/Kconfig"
+#source "drivers/amlogic/memory_ext/Kconfig"
+source "drivers/amlogic/bluetooth/Kconfig"
+source "drivers/amlogic/wifi/Kconfig"
+#source "drivers/amlogic/uart/Kconfig"
+#source "drivers/amlogic/smartcard_sc2/Kconfig"
+#source "drivers/amlogic/mtd/Kconfig"
+#source "drivers/amlogic/led/Kconfig"
+#source "drivers/amlogic/amaudio/Kconfig"
+#source "drivers/amlogic/audiodsp/Kconfig"
+#source "drivers/amlogic/audioinfo/Kconfig"
+#source "drivers/amlogic/dolby_fw/Kconfig"
+#source "drivers/amlogic/cpu_info/Kconfig"
+#source "drivers/amlogic/ethernet/phy/Kconfig"
+#source "drivers/amlogic/soc_info/Kconfig"
+#source "drivers/amlogic/gator-driver/Kconfig"
+#source "drivers/amlogic/global_timer/Kconfig"
+#source "drivers/amlogic/mfd/Kconfig"
+#source "drivers/amlogic/regulator/Kconfig"
+#source "drivers/amlogic/mfh/Kconfig"
+
+endmenu
+endif
diff -urN linux-5.10.y-a/drivers/amlogic/Makefile linux-5.10.y-b/drivers/amlogic/Makefile
--- linux-5.10.y-a/drivers/amlogic/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/drivers/amlogic/Makefile	2022-12-25 16:42:50.000000000 +0800
@@ -0,0 +1,80 @@
+
+##########################################
+########## Amlogic Drivers ###############
+##########################################
+
+
+# GKI extern modules if enabled AMLOGIC_GKI
+#obj-$(CONFIG_AMLOGIC_MESON_CPUFREQ)	+= cpufreq/
+#obj-$(CONFIG_AMLOGIC_SEC)               += secmon/
+#obj-$(CONFIG_AMLOGIC_EFUSE_UNIFYKEY)    += efuse_unifykey/
+#obj-$(CONFIG_AMLOGIC_DDR_TOOL)		+= ddr_tool/
+#obj-$(CONFIG_AMLOGIC_CRYPTO_DMA)	+= crypto/
+#obj-$(CONFIG_AMLOGIC_MHU_MBOX)		+= mailbox/
+#obj-$(CONFIG_AMLOGIC_REG_ACCESS)	+= reg_access/
+#obj-$(CONFIG_AMLOGIC_MEDIA_ENABLE)	+= media/
+#obj-$(CONFIG_AMLOGIC_PCIE)		+= pci/
+#obj-$(CONFIG_AMLOGIC_THERMAL)		+= thermal/
+#obj-$(CONFIG_AMLOGIC_CLK_DEBUG)		+= clk_debug/
+#obj-$(CONFIG_AMLOGIC_INPUT)		+= input/
+#obj-$(CONFIG_AMLOGIC_TEE)		+= tee/
+#obj-$(CONFIG_AMLOGIC_JTAG_MESON)	+= jtag/
+#obj-$(CONFIG_AMLOGIC_GX_REBOOT)		+= reboot/
+#obj-$(CONFIG_AMLOGIC_GKI_TOOL)		+= gki_tool/
+#obj-$(CONFIG_AMLOGIC_HIFI4DSP)          += hifi4dsp/
+#obj-$(CONFIG_AMLOGIC_DVB_COMPAT)        += dvb/
+#obj-$(CONFIG_AMLOGIC_DRM)		+= drm/
+#obj-$(CONFIG_AMLOGIC_IRBLASTER)		+= irblaster/
+#obj-$(CONFIG_MTD_NAND_MESON)		+= mtd/nand/
+#obj-$(CONFIG_MTD_RESV_MESON)		+= mtd/reserve/
+#obj-$(CONFIG_MTD_SPI_NAND_MESON)	+= mtd/spi_nand/
+#obj-$(CONFIG_AMLOGIC_AUDIO_DSP)  	+= audiodsp/
+#obj-$(CONFIG_AMLOGIC_AMAUDIO)		+= amaudio/
+#obj-$(CONFIG_AMLOGIC_AUDIO_INFO) 	+= audioinfo/
+#obj-$(CONFIG_AMLOGIC_ETH_PRIVE)		+= ethernet/phy/
+#obj-$(CONFIG_AMLOGIC_MEDIA_ALGORITHM)	+= algorithm/
+#obj-$(CONFIG_AMLOGIC_GLOBAL_TIMER)	+= global_timer/
+
+#Always build in code/modules
+#obj-$(CONFIG_AMLOGIC_CPUIDLE)		+= cpuidle/
+#obj-$(CONFIG_AMLOGIC_DEFENDKEY)		+= defendkey/
+#obj-$(CONFIG_AMLOGIC_AUTO_CAPTURE)	+= free_reserved/
+#obj-$(CONFIG_AMLOGIC_GX_SUSPEND)	+= pm/
+#obj-$(CONFIG_AMLOGIC_POWER)		+= power/
+#obj-$(CONFIG_AMLOGIC_DEBUG)		+= debug/
+obj-$(CONFIG_PWM_MESON)			+= pwm/
+#obj-$(CONFIG_AMLOGIC_LED)    		+= led/
+#obj-$(CONFIG_AMLOGIC_MEMORY_EXTEND)	+= memory_ext/
+obj-$(CONFIG_AMLOGIC_WIFI)		+= wifi/
+#obj-$(CONFIG_AMLOGIC_UART)		+= uart/
+obj-$(CONFIG_AMLOGIC_BT_DEVICE)		+= bluetooth/
+#obj-$(CONFIG_AMLOGIC_SMARTCARD)		+= smartcard/
+#obj-$(CONFIG_AMLOGIC_SMARTCARD)		+= smartcard_sc2/
+#obj-$(CONFIG_MMC_MESON_GX)		+= mmc/
+#obj-$(CONFIG_AMLOGIC_USB)               += usb/
+#obj-$(CONFIG_AMLOGIC_DVB_DMX)		+= dvb/
+#obj-$(CONFIG_DOLBY_FW) += dolby_fw/
+#obj-$(CONFIG_AMLOGIC_CPU_INFO)          += cpu_info/
+#obj-$(CONFIG_AMLOGIC_SOC_INFO) 		+= soc_info/
+#obj-$(CONFIG_GATOR)	+= gator-driver/
+#obj-$(CONFIG_AMLOGIC_MFD) += mfd/
+#obj-$(CONFIG_AMLOGIC_REGULATOR) += regulator/
+#obj-$(CONFIG_AMLOGIC_MFH_MODULE)     += mfh/
+
+KBUILD_CFLAGS_MODULE += $(GKI_EXT_MODULE_PREDEFINE)
+
+all:
+	@$(MAKE) -C $(KERNEL_SRC) M=$(M)  modules $(GKI_EXT_MODULE_CONFIG)
+
+modules_install:
+	@echo "$(MAKE) INSTALL_MOD_STRIP=1 M=$(M) -C $(KERNEL_SRC) modules_install"
+#	@$(MAKE) INSTALL_MOD_STRIP=1 M=$(M) -C $(KERNEL_SRC) modules_install
+#	mkdir -p ${OUT_DIR}/../vendor_lib/modules
+#	cd ${OUT_DIR}/$(M)/; find -name "*.ko" -exec cp {} ${OUT_DIR}/../vendor_lib/modules/ \;
+	mkdir -p ${OUT_DIR}/../vendor_lib/modules
+	(cd ${OUT_DIR}/$(M)/; find -name "dvb_demux.ko" -exec cp {} ${OUT_DIR}/../vendor_lib/modules/ \;)
+	(cd ${OUT_DIR}/$(M)/; find -name "aml_aucpu.ko" -exec cp {} ${OUT_DIR}/../vendor_lib/modules/ \;)
+
+clean:
+	$(MAKE) -C $(KERNEL_SRC) M=$(M) clean
+
diff -urN linux-5.10.y-a/drivers/amlogic/pwm/Makefile linux-5.10.y-b/drivers/amlogic/pwm/Makefile
--- linux-5.10.y-a/drivers/amlogic/pwm/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/drivers/amlogic/pwm/Makefile	2022-11-01 20:35:46.000000000 +0800
@@ -0,0 +1 @@
+obj-$(CONFIG_PWM_MESON) += pwm-meson-sysfs.o
diff -urN linux-5.10.y-a/drivers/amlogic/pwm/pwm-meson-sysfs.c linux-5.10.y-b/drivers/amlogic/pwm/pwm-meson-sysfs.c
--- linux-5.10.y-a/drivers/amlogic/pwm/pwm-meson-sysfs.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/drivers/amlogic/pwm/pwm-meson-sysfs.c	2022-11-01 20:35:46.000000000 +0800
@@ -0,0 +1,392 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#undef pr_fmt
+#define pr_fmt(fmt) "pwm: " fmt
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/pwm.h>
+#include <linux/amlogic/pwm-meson.h>
+
+/**
+ * pwm_constant_enable()
+ * - start a constant PWM output toggling
+ * @chip: aml_pwm_chip struct
+ * @index: pwm channel to choose,like PWM_A or PWM_B
+ */
+int pwm_constant_enable(struct meson_pwm *meson, int index)
+{
+	u32 enable;
+
+	switch (index) {
+	case 0:
+		enable = MISC_A_CONSTANT;
+		break;
+	case 1:
+		enable = MISC_B_CONSTANT;
+		break;
+	default:
+		return -EINVAL;
+	}
+	regmap_update_bits(meson->regmap_base, REG_MISC_AB, enable, enable);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pwm_constant_enable);
+
+/**
+ * pwm_constant_disable() - stop a constant PWM output toggling
+ * @chip: aml_pwm_chip struct
+ * @index: pwm channel to choose,like PWM_A or PWM_B
+ */
+int pwm_constant_disable(struct meson_pwm *meson, int index)
+{
+	u32 enable;
+
+	switch (index) {
+	case 0:
+		enable = BIT(28);
+		break;
+
+	case 1:
+		enable = BIT(29);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+	regmap_update_bits(meson->regmap_base,
+			   REG_MISC_AB, enable, PWM_DISABLE);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pwm_constant_disable);
+
+static ssize_t constant_show(struct device *child,
+			     struct device_attribute *attr,
+			     char *buf)
+{
+	struct meson_pwm *meson =
+		(struct meson_pwm *)dev_get_drvdata(child);
+	return sprintf(buf, "%d\n", meson->variant.constant);
+}
+
+static ssize_t constant_store(struct device *child,
+			      struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	struct meson_pwm *meson =
+		(struct meson_pwm *)dev_get_drvdata(child);
+	int val, ret, id, res;
+
+	res = sscanf(buf, "%d %d", &val, &id);
+	if (res != 2) {
+		dev_err(child, "Can't parse pwm id,usage:[value index]\n");
+		return -EINVAL;
+	}
+
+	switch (val) {
+	case 0:
+		ret = pwm_constant_disable(meson, id);
+		meson->variant.constant = 0;
+		break;
+	case 1:
+		ret = pwm_constant_enable(meson, id);
+		meson->variant.constant = 1;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret ? : size;
+}
+
+/**
+ * pwm_set_times() - set PWM times output toggling
+ *		     set pwm a1 and pwm a2 timer together
+ *		     and pwm a1 should be set first
+ * @chip: aml_pwm_chip struct
+ * @index: pwm channel to choose,like PWM_A or PWM_B,range from 1 to 15
+ * @value: blink times to set,range from 1 to 255
+ */
+int pwm_set_times(struct meson_pwm *meson,
+		  int index, int value)
+{
+	unsigned int clear_val, val;
+
+	if (value < 0 || value > 255) {
+		dev_err(meson->chip.dev,
+			"index or value is not within the scope!\n");
+		return -EINVAL;
+	}
+
+	switch (index) {
+	case 0:
+		clear_val = 0xff << 24;
+		val = value << 24;
+		break;
+	case 1:
+		clear_val = 0xff << 8;
+		val = value << 8;
+		break;
+	case 2:
+		clear_val = 0xff << 16;
+		val = value << 16;
+		break;
+	case 3:
+		clear_val = 0xff;
+		val = value;
+		break;
+	default:
+		return -EINVAL;
+	}
+	regmap_update_bits(meson->regmap_base, REG_TIME_AB, clear_val, val);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pwm_set_times);
+
+static ssize_t times_show(struct device *child,
+			  struct device_attribute *attr, char *buf)
+{
+	struct meson_pwm *meson =
+		(struct meson_pwm *)dev_get_drvdata(child);
+	return sprintf(buf, "%d\n", meson->variant.times);
+}
+
+static ssize_t times_store(struct device *child,
+			   struct device_attribute *attr,
+			   const char *buf, size_t size)
+{
+	struct meson_pwm *meson =
+		(struct meson_pwm *)dev_get_drvdata(child);
+	int val, ret, id, res;
+
+	res = sscanf(buf, "%d %d", &val, &id);
+	if (res != 2) {
+		dev_err(child,
+			"Can't parse pwm id and value,usage:[value index]\n");
+		return -EINVAL;
+	}
+	ret = pwm_set_times(meson, id, val);
+	meson->variant.times = val;
+
+	return ret ? : size;
+}
+
+/**
+ * pwm_blink_enable()
+ *	- start a blink PWM output toggling
+ *	  txl only support 8 channel blink output
+ * @chip: aml_pwm_chip struct
+ * @index: pwm channel to choose,like PWM_A or PWM_B
+ */
+int pwm_blink_enable(struct meson_pwm *meson, int index)
+{
+	u32 enable;
+
+	switch (index) {
+	case 0:
+		enable = BLINK_A;
+		break;
+	case 1:
+		enable = BLINK_B;
+		break;
+	default:
+		return -EINVAL;
+	}
+	regmap_update_bits(meson->regmap_base, REG_BLINK_AB, enable, enable);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pwm_blink_enable);
+
+/**
+ * pwm_blink_disable() - stop a constant PWM output toggling
+ * @chip: aml_pwm_chip struct
+ * @index: pwm channel to choose,like PWM_A or PWM_B
+ */
+int pwm_blink_disable(struct meson_pwm *meson, int index)
+{
+	u32 enable;
+
+	switch (index) {
+	case 0:
+		enable = BLINK_A;
+		break;
+
+	case 1:
+		enable = BLINK_B;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+	regmap_update_bits(meson->regmap_base,
+			   REG_BLINK_AB, enable, PWM_DISABLE);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pwm_blink_disable);
+
+static ssize_t blink_enable_show(struct device *child,
+				 struct device_attribute *attr, char *buf)
+{
+	struct meson_pwm *meson =
+		(struct meson_pwm *)dev_get_drvdata(child);
+	return sprintf(buf, "%d\n", meson->variant.blink_enable);
+}
+
+static ssize_t blink_enable_store(struct device *child,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	struct meson_pwm *meson =
+		(struct meson_pwm *)dev_get_drvdata(child);
+	int val, ret, id, res;
+
+	res = sscanf(buf, "%d %d", &val, &id);
+	if (res != 2) {
+		dev_err(child, "blink enable,Can't parse pwm id,usage:[value index]\n");
+		return -EINVAL;
+	}
+
+	switch (val) {
+	case 0:
+		ret = pwm_blink_disable(meson, id);
+		meson->variant.blink_enable = 0;
+		break;
+	case 1:
+		ret = pwm_blink_enable(meson, id);
+		meson->variant.blink_enable = 1;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret ? : size;
+}
+
+/**
+ * pwm_set_blink_times() - set PWM blink times output toggling
+ * @chip: aml_pwm_chip struct
+ * @index: pwm channel to choose,like PWM_A or PWM_B
+ * @value: blink times to set,range from 1 to 15
+ */
+int pwm_set_blink_times(struct meson_pwm *meson,
+			int index,
+			int value)
+{
+	unsigned int clear_val, val;
+
+	if (value < 0 || value > 15) {
+		dev_err(meson->chip.dev,
+			"value or index is not within the scope!\n");
+		return -EINVAL;
+	}
+	switch (index) {
+	case 0:
+		clear_val = 0xf;
+		val = value;
+		break;
+
+	case 1:
+		clear_val = 0xf << 4;
+		val = value << 4;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+	regmap_update_bits(meson->regmap_base, REG_BLINK_AB, clear_val, val);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pwm_set_blink_times);
+
+static ssize_t blink_times_show(struct device *child,
+				struct device_attribute *attr, char *buf)
+{
+	struct meson_pwm *meson =
+		(struct meson_pwm *)dev_get_drvdata(child);
+	return sprintf(buf, "%d\n", meson->variant.blink_times);
+}
+
+static ssize_t blink_times_store(struct device *child,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	struct meson_pwm *meson =
+		(struct meson_pwm *)dev_get_drvdata(child);
+	int val, ret, id, res;
+
+	res = sscanf(buf, "%d %d", &val, &id);
+	if (res != 2) {
+		dev_err(child,
+			"Can't parse pwm id and value,usage:[value index]\n");
+		return -EINVAL;
+	}
+	ret = pwm_set_blink_times(meson, id, val);
+	meson->variant.blink_times = val;
+
+	return ret ? : size;
+}
+
+int pwm_register_debug(struct meson_pwm *meson)
+{
+	unsigned int i, value;
+
+	for (i = 0; i < 8; i++) {
+		regmap_read(meson->regmap_base, 4 * i, &value);
+		pr_info("[base+%x] = %x\n", 4 * i, value);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pwm_register_debug);
+
+static DEVICE_ATTR_RW(constant);
+static DEVICE_ATTR_RW(times);
+static DEVICE_ATTR_RW(blink_enable);
+static DEVICE_ATTR_RW(blink_times);
+
+static struct attribute *pwm_attrs[] = {
+		&dev_attr_constant.attr,
+		&dev_attr_times.attr,
+		&dev_attr_blink_enable.attr,
+		&dev_attr_blink_times.attr,
+		NULL,
+};
+
+static struct attribute_group pwm_attr_group = {
+		.attrs = pwm_attrs,
+};
+
+int meson_pwm_sysfs_init(struct device *dev)
+{
+	int retval;
+
+	retval = sysfs_create_group(&dev->kobj, &pwm_attr_group);
+	if (retval) {
+		dev_err(dev,
+			"pwm sysfs group creation failed: %d\n", retval);
+		return retval;
+	}
+
+	return 0;
+}
+
+void meson_pwm_sysfs_exit(struct device *dev)
+{
+	sysfs_remove_group(&dev->kobj, &pwm_attr_group);
+}
diff -urN linux-5.10.y-a/drivers/amlogic/wifi/dhd_static_buf.c linux-5.10.y-b/drivers/amlogic/wifi/dhd_static_buf.c
--- linux-5.10.y-a/drivers/amlogic/wifi/dhd_static_buf.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/drivers/amlogic/wifi/dhd_static_buf.c	2022-11-27 09:30:02.000000000 +0800
@@ -0,0 +1,610 @@
+/*
+ * drivers/amlogic/wifi/dhd_static_buf.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#define pr_fmt(fmt)	"Wifi: %s: " fmt, __func__
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/skbuff.h>
+//#include <linux/wlan_plat.h>
+#include <linux/amlogic/dhd_buf.h>
+
+#define	DHD_STATIC_VERSION_STR		"101.10.361.10 (wlan=r892223-20210623-1)"
+#define STATIC_ERROR_LEVEL	BIT(0)
+#define STATIC_TRACE_LEVEL	BIT(1)
+#define STATIC_MSG_LEVEL	BIT(0)
+uint static_msg_level = STATIC_ERROR_LEVEL | STATIC_MSG_LEVEL;
+
+#define DHD_STATIC_MSG(x, args...) \
+do { \
+	if (static_msg_level & STATIC_MSG_LEVEL) { \
+		pr_err("[dhd] STATIC-MSG) %s : " x, __func__, ## args); \
+	} \
+} while (0)
+#define DHD_STATIC_ERROR(x, args...) \
+do { \
+	if (static_msg_level & STATIC_ERROR_LEVEL) { \
+		pr_err("[dhd] STATIC-ERROR) %s : " x, __func__, ## args); \
+	} \
+} while (0)
+#define DHD_STATIC_TRACE(x, args...) \
+do { \
+	if (static_msg_level & STATIC_TRACE_LEVEL) { \
+		pr_err("[dhd] STATIC-TRACE) %s : " x, __func__, ## args); \
+	} \
+} while (0)
+
+#define BCMDHD_SDIO
+#define BCMDHD_PCIE
+//#define BCMDHD_USB
+#define CONFIG_BCMDHD_VTS { : = y}
+#define CONFIG_BCMDHD_DEBUG { : = y}
+//#define BCMDHD_UNUSE_MEM
+
+enum dhd_prealloc_index {
+	DHD_PREALLOC_PROT = 0,
+#if defined(BCMDHD_SDIO)
+	DHD_PREALLOC_RXBUF = 1,
+	DHD_PREALLOC_DATABUF = 2,
+#endif /* BCMDHD_SDIO */
+	DHD_PREALLOC_OSL_BUF = 3,
+	DHD_PREALLOC_SKB_BUF = 4,
+	DHD_PREALLOC_WIPHY_ESCAN0 = 5,
+	DHD_PREALLOC_WIPHY_ESCAN1 = 6,
+	DHD_PREALLOC_DHD_INFO = 7,
+#if defined(BCMDHD_SDIO) || defined(BCMDHD_USB)
+	DHD_PREALLOC_DHD_WLFC_INFO = 8,
+#endif /* BCMDHD_SDIO | BCMDHD_USB */
+#ifdef BCMDHD_PCIE
+	DHD_PREALLOC_IF_FLOW_LKUP = 9,
+#endif /* BCMDHD_PCIE */
+	DHD_PREALLOC_MEMDUMP_BUF = 10,
+#if defined(CONFIG_BCMDHD_VTS) || defined(CONFIG_BCMDHD_DEBUG)
+	DHD_PREALLOC_MEMDUMP_RAM = 11,
+#endif /* CONFIG_BCMDHD_VTS | CONFIG_BCMDHD_DEBUG */
+#if defined(BCMDHD_SDIO) || defined(BCMDHD_USB)
+	DHD_PREALLOC_DHD_WLFC_HANGER = 12,
+#endif /* BCMDHD_SDIO | BCMDHD_USB */
+	DHD_PREALLOC_PKTID_MAP = 13,
+	DHD_PREALLOC_PKTID_MAP_IOCTL = 14,
+#if defined(CONFIG_BCMDHD_VTS) || defined(CONFIG_BCMDHD_DEBUG)
+	DHD_PREALLOC_DHD_LOG_DUMP_BUF = 15,
+	DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX = 16,
+#endif /* CONFIG_BCMDHD_VTS | CONFIG_BCMDHD_DEBUG */
+	DHD_PREALLOC_DHD_PKTLOG_DUMP_BUF = 17,
+	DHD_PREALLOC_STAT_REPORT_BUF = 18,
+	DHD_PREALLOC_WL_ESCAN = 19,
+	DHD_PREALLOC_FW_VERBOSE_RING = 20,
+	DHD_PREALLOC_FW_EVENT_RING = 21,
+	DHD_PREALLOC_DHD_EVENT_RING = 22,
+#if defined(BCMDHD_UNUSE_MEM)
+	DHD_PREALLOC_NAN_EVENT_RING = 23,
+#endif /* BCMDHD_UNUSE_MEM */
+	DHD_PREALLOC_MAX
+};
+
+#define STATIC_BUF_MAX_NUM	20
+#define STATIC_BUF_SIZE	(PAGE_SIZE * 2)
+
+#ifndef CUSTOM_LOG_DUMP_BUFSIZE_MB
+/* DHD_LOG_DUMP_BUF_SIZE 4 MB static memory in kernel */
+#define CUSTOM_LOG_DUMP_BUFSIZE_MB	4
+#endif /* CUSTOM_LOG_DUMP_BUFSIZE_MB */
+
+#define DHD_PREALLOC_PROT_SIZE	(16 * 1024)
+#define DHD_PREALLOC_RXBUF_SIZE	(24 * 1024)
+#define DHD_PREALLOC_DATABUF_SIZE	(64 * 1024)
+#define DHD_PREALLOC_OSL_BUF_SIZE	(STATIC_BUF_MAX_NUM * STATIC_BUF_SIZE)
+#define DHD_PREALLOC_WIPHY_ESCAN0_SIZE	(64 * 1024)
+#define DHD_PREALLOC_DHD_INFO_SIZE	(34 * 1024)
+#if defined(CONFIG_BCMDHD_VTS) || defined(CONFIG_BCMDHD_DEBUG)
+#define DHD_PREALLOC_MEMDUMP_RAM_SIZE	(1290 * 1024)
+#endif /* CONFIG_BCMDHD_VTS | CONFIG_BCMDHD_DEBUG */
+#define DHD_PREALLOC_DHD_WLFC_HANGER_SIZE	(73 * 1024)
+#if defined(CONFIG_BCMDHD_VTS) || defined(CONFIG_BCMDHD_DEBUG)
+#define DHD_PREALLOC_DHD_LOG_DUMP_BUF_SIZE \
+	(1024 * 1024 * CUSTOM_LOG_DUMP_BUFSIZE_MB)
+#define DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX_SIZE (8 * 1024)
+#endif /* CONFIG_BCMDHD_VTS | CONFIG_BCMDHD_DEBUG */
+#define DHD_PREALLOC_WL_ESCAN_SIZE	(70 * 1024)
+#ifdef CONFIG_64BIT
+#define DHD_PREALLOC_IF_FLOW_LKUP_SIZE	(20 * 1024 * 2)
+#else
+#define DHD_PREALLOC_IF_FLOW_LKUP_SIZE	(20 * 1024)
+#endif
+#define FW_VERBOSE_RING_SIZE		(256 * 1024)
+#define FW_EVENT_RING_SIZE		(64 * 1024)
+#define DHD_EVENT_RING_SIZE		(64 * 1024)
+#define NAN_EVENT_RING_SIZE		(64 * 1024)
+
+#if defined(CONFIG_64BIT)
+#define WLAN_DHD_INFO_BUF_SIZE	(24 * 1024)
+#define WLAN_DHD_WLFC_BUF_SIZE	(64 * 1024)
+#define WLAN_DHD_IF_FLOW_LKUP_SIZE	(64 * 1024)
+#else
+#define WLAN_DHD_INFO_BUF_SIZE	(16 * 1024)
+#define WLAN_DHD_WLFC_BUF_SIZE	(64 * 1024)
+#define WLAN_DHD_IF_FLOW_LKUP_SIZE	(20 * 1024)
+#endif /* CONFIG_64BIT */
+#define WLAN_DHD_MEMDUMP_SIZE	(800 * 1024)
+
+#define DHD_SKB_1PAGE_BUFSIZE	(PAGE_SIZE * 1)
+#define DHD_SKB_2PAGE_BUFSIZE	(PAGE_SIZE * 2)
+#define DHD_SKB_4PAGE_BUFSIZE	(PAGE_SIZE * 4)
+
+#define DHD_SKB_1PAGE_BUF_NUM	8
+#ifdef BCMDHD_PCIE
+#define DHD_SKB_2PAGE_BUF_NUM	192
+#elif defined(BCMDHD_SDIO)
+#define DHD_SKB_2PAGE_BUF_NUM	8
+#endif /* BCMDHD_PCIE */
+#define DHD_SKB_4PAGE_BUF_NUM	1
+
+/* The number is defined in linux_osl.c
+ * WLAN_SKB_1_2PAGE_BUF_NUM => STATIC_PKT_1_2PAGE_NUM
+ * WLAN_SKB_BUF_NUM => STATIC_PKT_MAX_NUM
+ */
+#if defined(BCMDHD_SDIO) || defined(BCMDHD_PCIE)
+#define WLAN_SKB_1_2PAGE_BUF_NUM ((DHD_SKB_1PAGE_BUF_NUM) + \
+		(DHD_SKB_2PAGE_BUF_NUM))
+#define WLAN_SKB_BUF_NUM ((WLAN_SKB_1_2PAGE_BUF_NUM) + (DHD_SKB_4PAGE_BUF_NUM))
+#endif
+
+void *wlan_static_prot;
+void *wlan_static_rxbuf;
+void *wlan_static_databuf;
+void *wlan_static_osl_buf;
+void *wlan_static_scan_buf0;
+void *wlan_static_scan_buf1;
+void *wlan_static_dhd_info_buf;
+void *wlan_static_dhd_wlfc_info_buf;
+void *wlan_static_if_flow_lkup;
+void *wlan_static_dhd_memdump_ram_buf;
+void *wlan_static_dhd_wlfc_hanger_buf;
+#if defined(CONFIG_BCMDHD_VTS) || defined(CONFIG_BCMDHD_DEBUG)
+void *wlan_static_dhd_log_dump_buf;
+void *wlan_static_dhd_log_dump_buf_ex;
+#endif /* CONFIG_BCMDHD_VTS | CONFIG_BCMDHD_DEBUG */
+void *wlan_static_wl_escan_info_buf;
+void *wlan_static_fw_verbose_ring_buf;
+void *wlan_static_fw_event_ring_buf;
+void *wlan_static_dhd_event_ring_buf;
+void *wlan_static_nan_event_ring_buf;
+
+#if defined(BCMDHD_SDIO) || defined(BCMDHD_PCIE)
+static struct sk_buff *wlan_static_skb[WLAN_SKB_BUF_NUM];
+#endif /* BCMDHD_SDIO | BCMDHD_PCIE */
+
+void *bcmdhd_mem_prealloc(int section, unsigned long size)
+{
+	DHD_STATIC_TRACE("sectoin %d, size %ld\n", section, size);
+	if (section == DHD_PREALLOC_PROT)
+		return wlan_static_prot;
+
+#if defined(BCMDHD_SDIO)
+	if (section == DHD_PREALLOC_RXBUF)
+		return wlan_static_rxbuf;
+
+	if (section == DHD_PREALLOC_DATABUF)
+		return wlan_static_databuf;
+#endif /* BCMDHD_SDIO */
+
+#if defined(BCMDHD_SDIO) || defined(BCMDHD_PCIE)
+	if (section == DHD_PREALLOC_SKB_BUF)
+		return wlan_static_skb;
+#endif /* BCMDHD_SDIO | BCMDHD_PCIE */
+
+	if (section == DHD_PREALLOC_WIPHY_ESCAN0)
+		return wlan_static_scan_buf0;
+
+	if (section == DHD_PREALLOC_WIPHY_ESCAN1)
+		return wlan_static_scan_buf1;
+
+	if (section == DHD_PREALLOC_OSL_BUF) {
+		if (size > DHD_PREALLOC_OSL_BUF_SIZE) {
+			DHD_STATIC_ERROR("request OSL_BUF(%lu) > %ld\n",
+				size, DHD_PREALLOC_OSL_BUF_SIZE);
+			return NULL;
+		}
+		return wlan_static_osl_buf;
+	}
+
+	if (section == DHD_PREALLOC_DHD_INFO) {
+		if (size > DHD_PREALLOC_DHD_INFO_SIZE) {
+			DHD_STATIC_ERROR("request DHD_INFO(%lu) > %d\n",
+				size, DHD_PREALLOC_DHD_INFO_SIZE);
+			return NULL;
+		}
+		return wlan_static_dhd_info_buf;
+	}
+#if defined(BCMDHD_SDIO) || defined(BCMDHD_USB)
+	if (section == DHD_PREALLOC_DHD_WLFC_INFO) {
+		if (size > WLAN_DHD_WLFC_BUF_SIZE) {
+			DHD_STATIC_ERROR("request DHD_WLFC_INFO(%lu) > %d\n",
+				size, WLAN_DHD_WLFC_BUF_SIZE);
+			return NULL;
+		}
+		return wlan_static_dhd_wlfc_info_buf;
+	}
+#endif /* BCMDHD_SDIO | BCMDHD_USB */
+#ifdef BCMDHD_PCIE
+	if (section == DHD_PREALLOC_IF_FLOW_LKUP)  {
+		if (size > DHD_PREALLOC_IF_FLOW_LKUP_SIZE) {
+			DHD_STATIC_ERROR("request DHD_IF_FLOW_LKUP(%lu) > %d\n",
+				size, DHD_PREALLOC_IF_FLOW_LKUP_SIZE);
+			return NULL;
+		}
+		return wlan_static_if_flow_lkup;
+	}
+#endif /* BCMDHD_PCIE */
+#if defined(CONFIG_BCMDHD_VTS) || defined(CONFIG_BCMDHD_DEBUG)
+	if (section == DHD_PREALLOC_MEMDUMP_RAM) {
+		if (size > DHD_PREALLOC_MEMDUMP_RAM_SIZE) {
+			DHD_STATIC_ERROR("request MEMDUMP_RAM(%lu) > %d\n",
+				size, DHD_PREALLOC_MEMDUMP_RAM_SIZE);
+			return NULL;
+		}
+		return wlan_static_dhd_memdump_ram_buf;
+	}
+#endif /* CONFIG_BCMDHD_VTS | CONFIG_BCMDHD_DEBUG */
+#if defined(BCMDHD_SDIO) || defined(BCMDHD_USB)
+	if (section == DHD_PREALLOC_DHD_WLFC_HANGER) {
+		if (size > DHD_PREALLOC_DHD_WLFC_HANGER_SIZE) {
+			DHD_STATIC_ERROR("request DHD_WLFC_HANGER(%lu) > %d\n",
+				size, DHD_PREALLOC_DHD_WLFC_HANGER_SIZE);
+			return NULL;
+		}
+		return wlan_static_dhd_wlfc_hanger_buf;
+	}
+#endif /* BCMDHD_SDIO | BCMDHD_USB */
+#if defined(CONFIG_BCMDHD_VTS) || defined(CONFIG_BCMDHD_DEBUG)
+	if (section == DHD_PREALLOC_DHD_LOG_DUMP_BUF) {
+		if (size > DHD_PREALLOC_DHD_LOG_DUMP_BUF_SIZE) {
+			DHD_STATIC_ERROR("request DHD_LOG_DUMP_BUF(%lu) > %d\n",
+				size, DHD_PREALLOC_DHD_LOG_DUMP_BUF_SIZE);
+			return NULL;
+		}
+		return wlan_static_dhd_log_dump_buf;
+	}
+	if (section == DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX) {
+		if (size > DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX_SIZE) {
+			DHD_STATIC_ERROR("request DUMP_BUF_EX(%lu) > %d\n",
+				size, DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX_SIZE);
+			return NULL;
+		}
+		return wlan_static_dhd_log_dump_buf_ex;
+	}
+#endif /* CONFIG_BCMDHD_VTS | CONFIG_BCMDHD_DEBUG */
+	if (section == DHD_PREALLOC_WL_ESCAN) {
+		if (size > DHD_PREALLOC_WL_ESCAN_SIZE) {
+			DHD_STATIC_ERROR("request WL_ESCAN(%lu) > %d\n",
+				size, DHD_PREALLOC_WL_ESCAN_SIZE);
+			return NULL;
+		}
+		return wlan_static_wl_escan_info_buf;
+	}
+	if (section == DHD_PREALLOC_FW_VERBOSE_RING) {
+		if (size > FW_VERBOSE_RING_SIZE) {
+			DHD_STATIC_ERROR("request FW_VERBOSE_RING(%lu) > %d\n",
+				size, FW_VERBOSE_RING_SIZE);
+			return NULL;
+		}
+		return wlan_static_fw_verbose_ring_buf;
+	}
+	if (section == DHD_PREALLOC_FW_EVENT_RING) {
+		if (size > FW_EVENT_RING_SIZE) {
+			DHD_STATIC_ERROR("request FW_EVENT_RING(%lu) > %d\n",
+				size, FW_EVENT_RING_SIZE);
+			return NULL;
+		}
+		return wlan_static_fw_event_ring_buf;
+	}
+	if (section == DHD_PREALLOC_DHD_EVENT_RING) {
+		if (size > DHD_EVENT_RING_SIZE) {
+			DHD_STATIC_ERROR("request DHD_EVENT_RING(%lu) > %d\n",
+				size, DHD_EVENT_RING_SIZE);
+			return NULL;
+		}
+		return wlan_static_dhd_event_ring_buf;
+	}
+#if defined(BCMDHD_UNUSE_MEM)
+	if (section == DHD_PREALLOC_NAN_EVENT_RING) {
+		if (size > NAN_EVENT_RING_SIZE) {
+			DHD_STATIC_ERROR("request DHD_NAN_RING(%lu) > %d\n",
+				size, NAN_EVENT_RING_SIZE);
+			return NULL;
+		}
+		return wlan_static_nan_event_ring_buf;
+	}
+#endif /* BCMDHD_UNUSE_MEM */
+	if (section < 0 || section > DHD_PREALLOC_MAX)
+		DHD_STATIC_ERROR("request section id(%d) is out of max %d\n",
+			section, DHD_PREALLOC_MAX);
+
+	DHD_STATIC_ERROR("failed to alloc section %d, size=%ld\n",
+		section, size);
+
+	return NULL;
+}
+EXPORT_SYMBOL(bcmdhd_mem_prealloc);
+
+int bcmdhd_init_wlan_mem(unsigned int all_buf)
+{
+#if defined(BCMDHD_SDIO) || defined(BCMDHD_PCIE)
+	int i;
+#endif
+	unsigned long size = 0;
+
+	DHD_STATIC_MSG("%s\n", DHD_STATIC_VERSION_STR);
+
+#if defined(BCMDHD_SDIO) || defined(BCMDHD_PCIE)
+	for (i = 0; i < WLAN_SKB_BUF_NUM; i++)
+		wlan_static_skb[i] = NULL;
+
+	for (i = 0; i < DHD_SKB_1PAGE_BUF_NUM; i++) {
+		wlan_static_skb[i] = dev_alloc_skb(DHD_SKB_1PAGE_BUFSIZE);
+		if (!wlan_static_skb[i])
+			goto err_skb_alloc;
+
+		size += DHD_SKB_1PAGE_BUFSIZE;
+		DHD_STATIC_TRACE("sectoin %d skb[%d], size=%ld\n",
+			DHD_PREALLOC_SKB_BUF, i, DHD_SKB_1PAGE_BUFSIZE);
+	}
+
+	for (i = DHD_SKB_1PAGE_BUF_NUM; i < WLAN_SKB_1_2PAGE_BUF_NUM; i++) {
+		wlan_static_skb[i] = dev_alloc_skb(DHD_SKB_2PAGE_BUFSIZE);
+		if (!wlan_static_skb[i])
+			goto err_skb_alloc;
+
+		size += DHD_SKB_2PAGE_BUFSIZE;
+		DHD_STATIC_TRACE("sectoin %d skb[%d], size=%ld\n",
+			DHD_PREALLOC_SKB_BUF, i, DHD_SKB_2PAGE_BUFSIZE);
+	}
+#endif /* BCMDHD_SDIO | BCMDHD_PCIE */
+	if (all_buf == 1) {
+#if defined(BCMDHD_SDIO)
+		wlan_static_skb[i] = dev_alloc_skb(DHD_SKB_4PAGE_BUFSIZE);
+		if (!wlan_static_skb[i])
+			goto err_skb_alloc;
+		size += DHD_SKB_4PAGE_BUFSIZE;
+		DHD_STATIC_TRACE("sectoin %d skb[%d], size=%ld\n",
+			DHD_PREALLOC_SKB_BUF, i, DHD_SKB_4PAGE_BUFSIZE);
+#endif /* BCMDHD_SDIO */
+
+		wlan_static_prot = kmalloc(DHD_PREALLOC_PROT_SIZE, GFP_KERNEL);
+		if (!wlan_static_prot)
+			goto err_mem_alloc;
+		size += DHD_PREALLOC_PROT_SIZE;
+		DHD_STATIC_TRACE("sectoin %d, size=%d\n",
+			DHD_PREALLOC_PROT, DHD_PREALLOC_PROT_SIZE);
+
+#if defined(BCMDHD_SDIO)
+		wlan_static_rxbuf =
+			kmalloc(DHD_PREALLOC_RXBUF_SIZE, GFP_KERNEL);
+		if (!wlan_static_rxbuf)
+			goto err_mem_alloc;
+		size += DHD_PREALLOC_RXBUF_SIZE;
+		DHD_STATIC_TRACE("sectoin %d, size=%d\n",
+			DHD_PREALLOC_RXBUF, DHD_PREALLOC_RXBUF_SIZE);
+
+		wlan_static_databuf =
+			kmalloc(DHD_PREALLOC_DATABUF_SIZE, GFP_KERNEL);
+		if (!wlan_static_databuf)
+			goto err_mem_alloc;
+		size += DHD_PREALLOC_DATABUF_SIZE;
+		DHD_STATIC_TRACE("sectoin %d, size=%d\n",
+			DHD_PREALLOC_DATABUF, DHD_PREALLOC_DATABUF_SIZE);
+#endif /* BCMDHD_SDIO */
+
+		wlan_static_osl_buf =
+			kmalloc(DHD_PREALLOC_OSL_BUF_SIZE, GFP_KERNEL);
+		if (!wlan_static_osl_buf)
+			goto err_mem_alloc;
+		size += DHD_PREALLOC_OSL_BUF_SIZE;
+		DHD_STATIC_TRACE("sectoin %d, size=%ld\n",
+			DHD_PREALLOC_OSL_BUF, DHD_PREALLOC_OSL_BUF_SIZE);
+
+		wlan_static_scan_buf0 =
+			kmalloc(DHD_PREALLOC_WIPHY_ESCAN0_SIZE, GFP_KERNEL);
+		if (!wlan_static_scan_buf0)
+			goto err_mem_alloc;
+		size += DHD_PREALLOC_WIPHY_ESCAN0_SIZE;
+		DHD_STATIC_TRACE("sectoin %d, size=%d\n",
+			DHD_PREALLOC_WIPHY_ESCAN0,
+			DHD_PREALLOC_WIPHY_ESCAN0_SIZE);
+
+		wlan_static_dhd_info_buf =
+			kmalloc(DHD_PREALLOC_DHD_INFO_SIZE, GFP_KERNEL);
+		if (!wlan_static_dhd_info_buf)
+			goto err_mem_alloc;
+		size += DHD_PREALLOC_DHD_INFO_SIZE;
+		DHD_STATIC_TRACE("sectoin %d, size=%d\n",
+			DHD_PREALLOC_DHD_INFO, DHD_PREALLOC_DHD_INFO_SIZE);
+
+#if defined(BCMDHD_SDIO) || defined(BCMDHD_USB)
+		wlan_static_dhd_wlfc_info_buf =
+			kmalloc(WLAN_DHD_WLFC_BUF_SIZE, GFP_KERNEL);
+		if (!wlan_static_dhd_wlfc_info_buf)
+			goto err_mem_alloc;
+		size += WLAN_DHD_WLFC_BUF_SIZE;
+		DHD_STATIC_TRACE("sectoin %d, size=%d\n",
+			DHD_PREALLOC_DHD_WLFC_INFO, WLAN_DHD_WLFC_BUF_SIZE);
+#endif /* BCMDHD_SDIO | BCMDHD_USB */
+
+#ifdef BCMDHD_PCIE
+		wlan_static_if_flow_lkup =
+			kmalloc(DHD_PREALLOC_IF_FLOW_LKUP_SIZE, GFP_KERNEL);
+		if (!wlan_static_if_flow_lkup)
+			goto err_mem_alloc;
+		size += DHD_PREALLOC_IF_FLOW_LKUP_SIZE;
+		DHD_STATIC_TRACE("sectoin %d, size=%d\n",
+			DHD_PREALLOC_IF_FLOW_LKUP,
+			DHD_PREALLOC_IF_FLOW_LKUP_SIZE);
+#endif /* BCMDHD_PCIE */
+	}
+
+#if defined(CONFIG_BCMDHD_VTS) || defined(CONFIG_BCMDHD_DEBUG)
+	wlan_static_dhd_memdump_ram_buf =
+		kmalloc(DHD_PREALLOC_MEMDUMP_RAM_SIZE, GFP_KERNEL);
+	if (!wlan_static_dhd_memdump_ram_buf)
+		goto err_mem_alloc;
+	size += DHD_PREALLOC_MEMDUMP_RAM_SIZE;
+	DHD_STATIC_TRACE("sectoin %d, size=%d\n",
+		DHD_PREALLOC_MEMDUMP_RAM, DHD_PREALLOC_MEMDUMP_RAM_SIZE);
+#endif /* CONFIG_BCMDHD_VTS | CONFIG_BCMDHD_DEBUG */
+	if (all_buf == 1) {
+#if defined(BCMDHD_SDIO) || defined(BCMDHD_USB)
+		wlan_static_dhd_wlfc_hanger_buf =
+			kmalloc(DHD_PREALLOC_DHD_WLFC_HANGER_SIZE, GFP_KERNEL);
+		if (!wlan_static_dhd_wlfc_hanger_buf)
+			goto err_mem_alloc;
+		size += DHD_PREALLOC_DHD_WLFC_HANGER_SIZE;
+		DHD_STATIC_TRACE("sectoin %d, size=%d\n",
+			DHD_PREALLOC_DHD_WLFC_HANGER,
+			DHD_PREALLOC_DHD_WLFC_HANGER_SIZE);
+#endif /* BCMDHD_SDIO | BCMDHD_USB */
+
+#if defined(CONFIG_BCMDHD_VTS) || defined(CONFIG_BCMDHD_DEBUG)
+		wlan_static_dhd_log_dump_buf =
+			kmalloc(DHD_PREALLOC_DHD_LOG_DUMP_BUF_SIZE, GFP_KERNEL);
+		if (!wlan_static_dhd_log_dump_buf)
+			goto err_mem_alloc;
+		size += DHD_PREALLOC_DHD_LOG_DUMP_BUF_SIZE;
+		DHD_STATIC_TRACE("sectoin %d, size=%d\n",
+			DHD_PREALLOC_DHD_LOG_DUMP_BUF,
+			DHD_PREALLOC_DHD_LOG_DUMP_BUF_SIZE);
+
+		wlan_static_dhd_log_dump_buf_ex =
+			kmalloc(DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX_SIZE,
+			GFP_KERNEL);
+		if (!wlan_static_dhd_log_dump_buf_ex)
+			goto err_mem_alloc;
+		size += DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX_SIZE;
+		DHD_STATIC_TRACE("sectoin %d, size=%d\n",
+			DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX,
+			DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX_SIZE);
+#endif /* CONFIG_BCMDHD_VTS | CONFIG_BCMDHD_DEBUG */
+
+		wlan_static_wl_escan_info_buf =
+			kmalloc(DHD_PREALLOC_WL_ESCAN_SIZE, GFP_KERNEL);
+		if (!wlan_static_wl_escan_info_buf)
+			goto err_mem_alloc;
+		size += DHD_PREALLOC_WL_ESCAN_SIZE;
+		DHD_STATIC_TRACE("sectoin %d, size=%d\n",
+			DHD_PREALLOC_WL_ESCAN, DHD_PREALLOC_WL_ESCAN_SIZE);
+	}
+	wlan_static_fw_verbose_ring_buf =
+		kmalloc(FW_VERBOSE_RING_SIZE, GFP_KERNEL);
+	if (!wlan_static_fw_verbose_ring_buf)
+		goto err_mem_alloc;
+	size += FW_VERBOSE_RING_SIZE;
+	DHD_STATIC_TRACE("sectoin %d, size=%d\n",
+		DHD_PREALLOC_FW_VERBOSE_RING, FW_VERBOSE_RING_SIZE);
+
+	if (all_buf == 1) {
+		wlan_static_fw_event_ring_buf =
+			kmalloc(FW_EVENT_RING_SIZE, GFP_KERNEL);
+		if (!wlan_static_fw_event_ring_buf)
+			goto err_mem_alloc;
+		size += FW_EVENT_RING_SIZE;
+		DHD_STATIC_TRACE("sectoin %d, size=%d\n",
+			DHD_PREALLOC_FW_EVENT_RING, FW_EVENT_RING_SIZE);
+
+		wlan_static_dhd_event_ring_buf =
+			kmalloc(DHD_EVENT_RING_SIZE, GFP_KERNEL);
+		if (!wlan_static_dhd_event_ring_buf)
+			goto err_mem_alloc;
+		size += DHD_EVENT_RING_SIZE;
+		DHD_STATIC_TRACE("sectoin %d, size=%d\n",
+			DHD_PREALLOC_DHD_EVENT_RING, DHD_EVENT_RING_SIZE);
+
+#if defined(BCMDHD_UNUSE_MEM)
+		wlan_static_nan_event_ring_buf =
+			kmalloc(NAN_EVENT_RING_SIZE, GFP_KERNEL);
+		if (!wlan_static_nan_event_ring_buf)
+			goto err_mem_alloc;
+		size += NAN_EVENT_RING_SIZE;
+		DHD_STATIC_TRACE("sectoin %d, size=%d\n",
+			DHD_PREALLOC_NAN_EVENT_RING, NAN_EVENT_RING_SIZE);
+#endif /* BCMDHD_UNUSE_MEM */
+	}
+	DHD_STATIC_MSG("prealloc ok: %ld(%ldK)\n", size, size / 1024);
+	return 0;
+
+err_mem_alloc:
+	if (all_buf == 1) {
+		kfree(wlan_static_prot);
+#if defined(BCMDHD_SDIO)
+		kfree(wlan_static_rxbuf);
+		kfree(wlan_static_databuf);
+#endif /* BCMDHD_SDIO */
+		kfree(wlan_static_osl_buf);
+		kfree(wlan_static_scan_buf0);
+		kfree(wlan_static_scan_buf1);
+		kfree(wlan_static_dhd_info_buf);
+#if defined(BCMDHD_SDIO) || defined(BCMDHD_USB)
+		kfree(wlan_static_dhd_wlfc_info_buf);
+#endif /* BCMDHD_SDIO | BCMDHD_USB */
+#ifdef BCMDHD_PCIE
+		kfree(wlan_static_if_flow_lkup);
+#endif /* BCMDHD_PCIE */
+	}
+#if defined(CONFIG_BCMDHD_VTS) || defined(CONFIG_BCMDHD_DEBUG)
+		kfree(wlan_static_dhd_memdump_ram_buf);
+#endif /* CONFIG_BCMDHD_VTS | CONFIG_BCMDHD_DEBUG */
+	if (all_buf == 1) {
+#if defined(BCMDHD_SDIO) || defined(BCMDHD_USB)
+		kfree(wlan_static_dhd_wlfc_hanger_buf);
+#endif /* BCMDHD_SDIO | BCMDHD_USB */
+#if defined(CONFIG_BCMDHD_VTS) || defined(CONFIG_BCMDHD_DEBUG)
+		kfree(wlan_static_dhd_log_dump_buf);
+		kfree(wlan_static_dhd_log_dump_buf_ex);
+#endif /* CONFIG_BCMDHD_VTS | CONFIG_BCMDHD_DEBUG */
+		kfree(wlan_static_wl_escan_info_buf);
+	}
+#ifdef BCMDHD_PCIE
+	kfree(wlan_static_fw_verbose_ring_buf);
+	if (all_buf == 1) {
+		kfree(wlan_static_fw_event_ring_buf);
+		kfree(wlan_static_dhd_event_ring_buf);
+#if defined(BCMDHD_UNUSE_MEM)
+		kfree(wlan_static_nan_event_ring_buf);
+#endif /* BCMDHD_UNUSE_MEM */
+	}
+#endif /* BCMDHD_PCIE */
+
+	DHD_STATIC_ERROR("Failed to mem_alloc for WLAN\n");
+
+#if defined(BCMDHD_SDIO) || defined(BCMDHD_PCIE)
+err_skb_alloc:
+	DHD_STATIC_ERROR("Failed to skb_alloc for WLAN\n");
+	for (i = 0; i < WLAN_SKB_BUF_NUM; i++) {
+		if (wlan_static_skb[i])
+			dev_kfree_skb(wlan_static_skb[i]);
+	}
+#endif /* BCMDHD_SDIO | BCMDHD_PCIE */
+
+	return -ENOMEM;
+}
+EXPORT_SYMBOL(bcmdhd_init_wlan_mem);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("AMLOGIC");
+MODULE_DESCRIPTION("wifi device tree driver");
diff -urN linux-5.10.y-a/drivers/amlogic/wifi/Kconfig linux-5.10.y-b/drivers/amlogic/wifi/Kconfig
--- linux-5.10.y-a/drivers/amlogic/wifi/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/drivers/amlogic/wifi/Kconfig	2022-11-27 09:30:04.000000000 +0800
@@ -0,0 +1,23 @@
+menuconfig AMLOGIC_WIFI
+	tristate "WiFi support"
+	select WIRELESS_EXT
+	select WEXT_PRIV
+	default y
+	help
+		select y to support wifi
+
+if AMLOGIC_WIFI
+
+config AMLOGIC_PWM_32K
+	bool "amlogic soc pwm 32k support"
+	depends on PWM_MESON
+	default y
+	help
+		WiFi usually needs a 32K frequency clock signal.
+		There are three possibilities:
+		using the internal 32K clock or using the 32K input from our SOC,
+		or using the onboard active 32K crystal oscillator.
+		By default,32K of SOC input is enabled,
+		if not, you can disable it by selecting n.
+
+endif
diff -urN linux-5.10.y-a/drivers/amlogic/wifi/Makefile linux-5.10.y-b/drivers/amlogic/wifi/Makefile
--- linux-5.10.y-a/drivers/amlogic/wifi/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/drivers/amlogic/wifi/Makefile	2023-01-06 16:03:32.000000000 +0800
@@ -0,0 +1,5 @@
+MODULE_NAME = aml_wifi
+
+#obj-$(CONFIG_AMLOGIC_WIFI) = $(MODULE_NAME).o
+obj-y = $(MODULE_NAME).o
+$(MODULE_NAME)-y = wifi_dt.o dhd_static_buf.o
diff -urN linux-5.10.y-a/drivers/amlogic/wifi/wifi_dt.c linux-5.10.y-b/drivers/amlogic/wifi/wifi_dt.c
--- linux-5.10.y-a/drivers/amlogic/wifi/wifi_dt.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/drivers/amlogic/wifi/wifi_dt.c	2023-01-11 11:53:32.000000000 +0800
@@ -0,0 +1,1041 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * drivers/amlogic/wifi/wifi_dt.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/amlogic/wifi_dt.h>
+#include <linux/amlogic/dhd_buf.h>
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/of_irq.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/proc_fs.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio.h>
+#include <linux/amlogic/cpu_version.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/pci.h>
+#ifdef CONFIG_AMLOGIC_PWM_32K
+#include <linux/pwm.h>
+#include <linux/amlogic/pwm-meson.h>
+#endif
+#include "../../gpio/gpiolib-of.h"
+#define OWNER_NAME "sdio_wifi"
+
+struct pcie_wifi_chip {
+	unsigned int vendor;
+	unsigned int device;
+};
+
+static const struct pcie_wifi_chip pcie_wifi[] = {
+	{0x16c3, 0xabcd}
+};
+
+int wifi_power_gpio;
+int wifi_power_gpio2;
+
+/*this function tells wifi is using sd(sdiob) or sdio(sdioa)*/
+char *get_wifi_inf(void)
+{
+        return "sdiob";
+}
+EXPORT_SYMBOL(get_wifi_inf);
+
+#ifdef CONFIG_AMLOGIC_PWM_32K
+/*
+ *there are two pwm channel outputs using one gpio
+ *for gxtvbb and the follows soc
+ */
+struct pwm_double_data {
+	struct pwm_device *pwm;
+	unsigned int duty_cycle;
+	unsigned int pwm_times;
+};
+
+struct pwm_double_datas {
+	int num_pwm;
+	struct pwm_double_data pwms[2];
+};
+
+struct pwm_single_data {
+	struct pwm_device *pwm;
+	unsigned int duty_cycle;
+};
+#endif
+
+struct wifi_plat_info {
+	int interrupt_pin;
+	int irq_num;
+	int irq_trigger_type;
+
+	int power_on_pin;
+	int power_on_pin_level;
+	int power_on_pin_OD;
+	int power_on_pin2;
+	int chip_en_pin;
+	int power_init_off;
+
+	int clock_32k_pin;
+	struct gpio_desc *interrupt_desc;
+	struct gpio_desc *powe_desc;
+
+	int plat_info_valid;
+	struct pinctrl *p;
+	struct device		*dev;
+#ifdef CONFIG_AMLOGIC_PWM_32K
+	struct pwm_double_datas ddata;
+	struct pwm_single_data sdata;
+#endif
+};
+
+#define WIFI_POWER_MODULE_NAME	"wifi_power"
+#define WIFI_POWER_DRIVER_NAME	"wifi_power"
+#define WIFI_POWER_DEVICE_NAME	"wifi_power"
+#define WIFI_POWER_CLASS_NAME		"wifi_power"
+
+#define USB_POWER_UP    _IO('m', 1)
+#define USB_POWER_DOWN  _IO('m', 2)
+#define WIFI_POWER_UP    _IO('m', 3)
+#define WIFI_POWER_DOWN  _IO('m', 4)
+#define SDIO_GET_DEV_TYPE  _IO('m', 5)
+static struct wifi_plat_info wifi_info;
+static dev_t wifi_power_devno;
+static struct cdev *wifi_power_cdev;
+static struct device *devp;
+struct wifi_power_platform_data *pdata;
+
+static int usb_power;
+#define BT_BIT	0
+#define WIFI_BIT	1
+static DEFINE_MUTEX(wifi_bt_mutex);
+
+#define WIFI_INFO(fmt, args...)	\
+	dev_info(wifi_info.dev, "[%s] " fmt, __func__, ##args)
+
+#ifdef CONFIG_OF
+static const struct of_device_id wifi_match[] = {
+	{
+		.compatible = "amlogic, aml-wifi",
+		.data		= (void *)&wifi_info
+	},
+	{},
+};
+
+static struct wifi_plat_info *wifi_get_driver_data
+	(struct platform_device *pdev)
+{
+	const struct of_device_id *match;
+
+	match = of_match_node(wifi_match, pdev->dev.of_node);
+	if (!match)
+		return NULL;
+	return (struct wifi_plat_info *)match->data;
+}
+#else
+#define wifi_match NULL
+#endif
+
+#define SHOW_PIN_OWN(pin_str, pin_num)	\
+	WIFI_INFO("%s(%d)\n", pin_str, pin_num)
+
+static int set_power(int value)
+{
+	if (!wifi_info.power_on_pin_OD) {
+		if (wifi_info.power_on_pin_level)
+			return gpio_direction_output(wifi_info.power_on_pin,
+					!value);
+		else
+			return gpio_direction_output(wifi_info.power_on_pin,
+					value);
+	} else {
+		if (wifi_info.power_on_pin_level) {
+			if (value)
+				gpio_direction_input(wifi_info.power_on_pin);
+			else
+				gpio_direction_output(wifi_info.power_on_pin,
+						      0);
+		} else {
+			if (value)
+				gpio_direction_output(wifi_info.power_on_pin,
+						      0);
+			else
+				gpio_direction_input(wifi_info.power_on_pin);
+		}
+	}
+	return 0;
+}
+
+static int set_power2(int value)
+{
+	if (wifi_info.power_on_pin_level)
+		return gpio_direction_output(wifi_info.power_on_pin2,
+				!value);
+	else
+		return gpio_direction_output(wifi_info.power_on_pin2,
+				value);
+}
+
+static int set_wifi_power(int is_power)
+{
+	int ret = 0;
+
+	if (is_power) {
+		if (wifi_info.power_on_pin) {
+			ret = set_power(1);
+			if (ret)
+				WIFI_INFO("power up failed(%d)\n", ret);
+		}
+		if (wifi_info.power_on_pin2) {
+			ret = set_power2(1);
+			if (ret)
+				WIFI_INFO("power2 up failed(%d)\n", ret);
+		}
+		sdio_reinit();
+	} else {
+		if (wifi_info.power_on_pin) {
+			ret = set_power(0);
+			if (ret)
+				WIFI_INFO("power down failed(%d)\n", ret);
+		}
+		if (wifi_info.power_on_pin2) {
+			ret = set_power2(0);
+			if (ret)
+				WIFI_INFO("power2 down failed(%d)\n", ret);
+		}
+	}
+	return ret;
+}
+
+static void usb_power_control(int is_power, int shift)
+{
+	mutex_lock(&wifi_bt_mutex);
+	if (is_power) {
+		if (!usb_power) {
+			set_wifi_power(is_power);
+			WIFI_INFO("Set %s power on !\n",
+				  (shift ? "WiFi" : "BT"));
+			msleep(200);
+			sdio_reinit();
+		}
+		usb_power |= (1 << shift);
+		WIFI_INFO("Set %s power on !\n",
+			  (shift ? "WiFi" : "BT"));
+		
+	} else {
+		usb_power &= ~(1 << shift);
+		if (!usb_power) {
+			set_wifi_power(is_power);
+			msleep(200);
+			WIFI_INFO("Set %s power down\n",
+				  (shift ? "WiFi" : "BT"));
+		}
+	}
+	mutex_unlock(&wifi_bt_mutex);
+}
+
+void set_usb_bt_power(int is_power)
+{
+	usb_power_control(is_power, BT_BIT);
+}
+EXPORT_SYMBOL(set_usb_bt_power);
+
+void set_usb_wifi_power(int is_power)
+{
+	usb_power_control(is_power, WIFI_BIT);
+}
+EXPORT_SYMBOL(set_usb_wifi_power);
+static int  wifi_power_open(struct inode *inode, struct file *file)
+{
+	struct cdev *cdevp = inode->i_cdev;
+
+	file->private_data = cdevp;
+	return 0;
+}
+
+static int  wifi_power_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+#ifdef CONFIG_PCI
+void pci_remove(void)
+{
+	struct pci_dev *device = NULL;
+	struct pci_dev *devicebus = NULL;
+	int n = 0;
+	int i = 0;
+
+	WIFI_INFO("pci remove!\n");
+	n = (int)(sizeof(pcie_wifi) / sizeof(struct pcie_wifi_chip));
+	for (i = 0; i < n; i++) {
+		device = pci_get_device(pcie_wifi[i].vendor,
+			pcie_wifi[i].device, NULL);
+		if (device) {
+			WIFI_INFO("found device 0x%x:0x%x, remove it!\n",
+				pcie_wifi[i].vendor, pcie_wifi[i].device);
+			devicebus = device->bus->self;
+			pci_stop_and_remove_bus_device_locked(device);
+			if (devicebus) {
+				WIFI_INFO("remove bus!\n");
+				pci_stop_and_remove_bus_device_locked(devicebus);
+			}
+		}
+	}
+}
+EXPORT_SYMBOL(pci_remove);
+
+void pci_reinit(void)
+{
+	struct pci_bus *bus = NULL;
+	int cnt = 20;
+
+	WIFI_INFO("pci wifi reinit!\n");
+
+	pci_lock_rescan_remove();
+	while ((bus = pci_find_next_bus(bus)) != NULL) {
+		pci_rescan_bus(bus);
+		WIFI_INFO("rescanning pci device\n");
+		cnt--;
+		if (cnt <= 0)
+			break;
+	}
+	pci_unlock_rescan_remove();
+}
+#else
+void pci_reinit(void)
+{
+	WIFI_INFO("PCI disabled!\n");
+}
+#endif
+EXPORT_SYMBOL(pci_reinit);
+
+#ifdef CONFIG_PCI
+void pci_remove_reinit(unsigned int vid, unsigned int pid, unsigned int del_bus)
+{
+	struct pci_bus *bus = NULL;
+	struct pci_dev *dev_device = NULL;
+	struct pci_dev *dev_bus = NULL;
+	int cnt = 20;
+
+	WIFI_INFO("pci wifi remove and reinit\n");
+	dev_device = pci_get_device(vid, pid, NULL);
+
+	if (dev_device) {
+		WIFI_INFO("device 0x%x:0x%x found, remove it\n", vid, pid);
+		dev_bus = dev_device->bus->self;
+		pci_stop_and_remove_bus_device_locked(dev_device);
+
+		if (del_bus > 0 && dev_bus) {
+			WIFI_INFO("remove ths bus this device on!\n");
+			pci_stop_and_remove_bus_device_locked(dev_bus);
+		}
+	} else {
+		WIFI_INFO("target pci device not found 0x%x:0x%x\n", vid, pid);
+	}
+
+	set_usb_wifi_power(0);
+	set_usb_wifi_power(1);
+
+	pci_lock_rescan_remove();
+	while ((bus = pci_find_next_bus(bus)) != NULL) {
+		pci_rescan_bus(bus);
+		WIFI_INFO("rescanning pci device\n");
+		cnt--;
+		if (cnt <= 0)
+			break;
+	}
+	pci_unlock_rescan_remove();
+}
+#else
+void pci_remove_reinit(unsigned int vid, unsigned int pid, unsigned int del_bus)
+{
+	WIFI_INFO("PCI disabled!\n");
+}
+#endif
+EXPORT_SYMBOL(pci_remove_reinit);
+
+static long wifi_power_ioctl(struct file *filp,
+			     unsigned int cmd, unsigned long arg)
+{
+	char dev_type[10] = {'\0'};
+
+	switch (cmd) {
+	case USB_POWER_UP:
+		set_usb_wifi_power(0);
+		set_usb_wifi_power(1);
+		WIFI_INFO(KERN_INFO "ioctl Set usb_sdio wifi power up!\n");
+		break;
+	case USB_POWER_DOWN:
+		set_usb_wifi_power(0);
+		WIFI_INFO(KERN_INFO "ioctl Set usb_sdio wifi power down!\n");
+		break;
+	case WIFI_POWER_UP:
+		pci_remove();
+		set_usb_wifi_power(0);
+		set_usb_wifi_power(1);
+		pci_reinit();
+		WIFI_INFO("Set sdio wifi power up!\n");
+		break;
+	case WIFI_POWER_DOWN:
+		set_usb_wifi_power(0);
+		WIFI_INFO("ioctl Set sdio wifi power down!\n");
+		break;
+	case SDIO_GET_DEV_TYPE:
+		if (strlen(get_wifi_inf()) >= sizeof(dev_type))
+			memcpy(dev_type, get_wifi_inf(),
+			       (sizeof(dev_type) - 1));
+		else
+			memcpy(dev_type, get_wifi_inf(),
+			       strlen(get_wifi_inf()));
+		WIFI_INFO("wifi interface dev type: %s, length = %d\n",
+			  dev_type, (int)strlen(dev_type));
+		if (copy_to_user((char __user *)arg,
+				 dev_type, strlen(dev_type)))
+			return -ENOTTY;
+		break;
+	default:
+		WIFI_INFO("usb %s: default !!!\n", __func__);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static struct class *wifi_dt_class;
+static ssize_t power_show(struct class *cls,
+			  struct class_attribute *attr,
+			  char *_buf)
+{
+	if (!_buf)
+		return -EINVAL;
+
+	return sprintf(_buf, "%s%s%s",
+		"wifi power ctrl:\n",
+		"1=power on\n",
+		"2=power down\n");
+}
+
+static ssize_t power_store(struct class *cls,
+			   struct class_attribute *attr,
+			   const char __user *buf, size_t count)
+{
+	int ret = -EINVAL;
+	unsigned char cmd = 0;
+
+	if (!buf || 0 != kstrtou8(buf, 0, &cmd))
+		return ret;
+
+	WIFI_INFO("wifi power ctrl: cmd = %d\n", (int)cmd);
+	switch (cmd) {
+	case 1:
+		pci_remove();
+		set_usb_wifi_power(0);
+		set_usb_wifi_power(1);
+		pci_reinit();
+		WIFI_INFO("set wifi power up!\n");
+		break;
+	case 2:
+		set_usb_wifi_power(0);
+		WIFI_INFO("set wifi power down!\n");
+		break;
+	default:
+		WIFI_INFO("wifi power ctrl: Invalid parameter!!!\n");
+		return ret;
+	}
+
+	return count;
+}
+static CLASS_ATTR_RW(power);
+
+static const struct file_operations wifi_power_fops = {
+	.unlocked_ioctl = wifi_power_ioctl,
+	.compat_ioctl = wifi_power_ioctl,
+	.open	= wifi_power_open,
+	.release	= wifi_power_release,
+};
+
+static struct class wifi_power_class = {
+	.name = WIFI_POWER_CLASS_NAME,
+	.owner = THIS_MODULE,
+};
+
+static int wifi_setup_dt(void)
+{
+	int ret;
+
+	WIFI_INFO("%s\n", __func__);
+	if (!wifi_info.plat_info_valid) {
+		WIFI_INFO("%s : invalid device tree setting\n", __func__);
+		return -1;
+	}
+
+	/* setup irq */
+	if (wifi_info.interrupt_pin) {
+		ret = gpio_request(wifi_info.interrupt_pin,
+				   OWNER_NAME);
+		if (ret)
+			WIFI_INFO("interrupt_pin request failed(%d)\n", ret);
+
+		ret = gpio_direction_input(wifi_info.interrupt_pin);
+		if (ret)
+			WIFI_INFO("set interrupt_pin input failed(%d)\n", ret);
+
+		wifi_info.irq_num = gpio_to_irq(wifi_info.interrupt_pin);
+		if (wifi_info.irq_num)
+			WIFI_INFO("irq num is:(%d)\n", wifi_info.irq_num);
+
+		SHOW_PIN_OWN("interrupt_pin", wifi_info.interrupt_pin);
+	}
+
+	/* setup power */
+	if (wifi_info.chip_en_pin) {
+		ret = gpio_request(wifi_info.chip_en_pin, OWNER_NAME);
+		if (ret)
+			WIFI_INFO("chip_en_pin request failed(%d)\n", ret);
+		ret = gpio_direction_output(wifi_info.chip_en_pin, 0);
+		if (ret)
+			WIFI_INFO("chip_en_pin output 0 failed(%d)\n", ret);
+		msleep(20);
+		ret = gpio_direction_output(wifi_info.chip_en_pin, 1);
+		if (ret)
+			WIFI_INFO("chip_en_pin output 1 failed(%d)\n", ret);
+		SHOW_PIN_OWN("chip_en_pin", wifi_info.chip_en_pin);
+	}
+
+	if (wifi_info.power_on_pin) {
+		ret = gpio_request(wifi_info.power_on_pin, OWNER_NAME);
+		if (ret)
+			WIFI_INFO("power_on_pin request failed(%d)\n", ret);
+		if (wifi_info.power_init_off) {
+			if (wifi_info.power_on_pin_level)
+				ret = set_power(1);
+			else
+				ret = set_power(0);
+		} else {
+			if (wifi_info.power_on_pin_level)
+				ret = set_power(0);
+			else
+				ret = set_power(1);
+		}
+		if (ret)
+			WIFI_INFO("power_on_pin output failed(%d)\n", ret);
+		SHOW_PIN_OWN("power_on_pin", wifi_info.power_on_pin);
+	}
+
+	if (wifi_info.power_on_pin2) {
+		ret = gpio_request(wifi_info.power_on_pin2,
+				   OWNER_NAME);
+		if (ret)
+			WIFI_INFO("power_on_pin2 request failed(%d)\n", ret);
+		if (wifi_info.power_on_pin_level)
+			ret = set_power2(1);
+		else
+			ret = set_power2(0);
+		if (ret)
+			WIFI_INFO("power_on_pin2 output failed(%d)\n", ret);
+		SHOW_PIN_OWN("power_on_pin2", wifi_info.power_on_pin2);
+	}
+
+	set_wifi_power(0);
+	msleep(100);
+	set_wifi_power(1);
+
+	return 0;
+}
+
+static void wifi_teardown_dt(void)
+{
+	WIFI_INFO("%s\n", __func__);
+	if (!wifi_info.plat_info_valid) {
+		WIFI_INFO("%s : invalid device tree setting\n", __func__);
+		return;
+	}
+
+	if (wifi_info.power_on_pin)
+		gpio_free(wifi_info.power_on_pin);
+
+	if (wifi_info.power_on_pin2)
+		gpio_free(wifi_info.power_on_pin2);
+
+	if (wifi_info.interrupt_pin)
+		gpio_free(wifi_info.interrupt_pin);
+}
+
+#ifdef CONFIG_AMLOGIC_PWM_32K
+/*
+ * for gxb ,m8b soc
+ * single pwm channel
+ */
+int pwm_single_channel_conf(struct wifi_plat_info *plat)
+{
+	struct pwm_device *pwm = plat->sdata.pwm;
+	struct pwm_state pstate;
+	int duty_value;
+	int ret;
+
+	/* get pwm duty_cycle property */
+	ret = of_property_read_u32(plat->dev->of_node, "duty_cycle",
+				   &duty_value);
+	if (ret) {
+		pr_err("not config pwm duty_cycle");
+		return ret;
+	}
+	/* get pwm device */
+	pwm = devm_pwm_get(plat->dev, NULL);
+	if (IS_ERR(pwm)) {
+		ret = PTR_ERR(pwm);
+		dev_err(plat->dev, "Failed to get PWM: %d\n", ret);
+		return ret;
+	}
+	/* config pwm */
+	pwm_init_state(pwm, &pstate);
+	pwm_config(pwm, duty_value, pstate.period);
+	pwm_enable(pwm);
+
+	WIFI_INFO("pwm period val=%lld, pwm duty val=%lld\n",
+		  pstate.period, pstate.duty_cycle);
+	WIFI_INFO("wifi pwm conf ok\n");
+
+	return 0;
+}
+
+int pwm_double_channel_conf_dt(struct wifi_plat_info *plat)
+{
+	phandle pwm_phandle;
+	int ret;
+	struct device_node *wifinode = plat->dev->of_node;
+	struct device_node *pnode = NULL;
+	struct device_node *child;
+
+	ret = of_property_read_u32(wifinode, "pwm_config", &pwm_phandle);
+	if (ret) {
+		pr_err("not match wifi_pwm_config node\n");
+		return -1;
+	}
+
+	pnode = of_find_node_by_phandle(pwm_phandle);
+	if (!pnode) {
+		pr_err("can't find wifi_pwm_config node\n");
+		return -1;
+	}
+
+	/*request for pwm device */
+	for_each_child_of_node(pnode, child) {
+		struct pwm_double_data *pdata =
+			&plat->ddata.pwms[plat->ddata.num_pwm];
+
+		pdata->pwm = devm_of_pwm_get(plat->dev, child, NULL);
+		if (IS_ERR(pdata->pwm)) {
+			ret = PTR_ERR(pdata->pwm);
+			dev_err(plat->dev, "unable to request PWM%d, ret = %d\n",
+				plat->ddata.num_pwm, ret);
+			return ret;
+		}
+		ret = of_property_read_u32(child, "duty-cycle",
+					   &pdata->duty_cycle);
+		if (ret) {
+			pr_err("not %d duty_cycle parameters\n",
+			       plat->ddata.num_pwm);
+			return ret;
+		}
+		ret = of_property_read_u32(child, "times",
+					   &pdata->pwm_times);
+		if (ret) {
+			pr_err("not %d pwm_times parameters\n",
+			       plat->ddata.num_pwm);
+			return ret;
+		}
+		plat->ddata.num_pwm++;
+	}
+	WIFI_INFO("wifi pwm dt ok\n");
+
+	return 0;
+}
+
+/*
+ *configuration for double pwm
+ */
+int pwm_double_channel_conf(struct wifi_plat_info *plat)
+{
+	struct pwm_double_data pwm_data1 = plat->ddata.pwms[0];
+	struct pwm_double_data pwm_data2 = plat->ddata.pwms[1];
+	struct pwm_device *pwm1 = pwm_data1.pwm;
+	struct pwm_device *pwm2 = pwm_data2.pwm;
+	struct meson_pwm *meson1 = to_meson_pwm(pwm1->chip);
+	struct meson_pwm *meson2 = to_meson_pwm(pwm2->chip);
+	struct pwm_state pstate1;
+	struct pwm_state pstate2;
+	unsigned int pwm1_duty = pwm_data1.duty_cycle;
+	unsigned int pwm1_times = pwm_data1.pwm_times;
+	unsigned int pwm2_duty = pwm_data2.duty_cycle;
+	unsigned int pwm2_times = pwm_data2.pwm_times;
+	int ret = 0;
+
+	/*init for pwm2 device*/
+	pwm_init_state(pwm1, &pstate1);
+	pwm_init_state(pwm2, &pstate2);
+
+	pwm_config(pwm1, pwm1_duty, pstate1.period);
+	pwm_config(pwm2, pwm2_duty, pstate2.period);
+
+	ret = pwm_set_times(meson1, pwm1->hwpwm, pwm1_times);
+	if (ret) {
+		pr_err("[%s][%d]wifi: pwm_set_times filed\n",
+		       __func__, __LINE__);
+		return ret;
+	}
+	ret = pwm_set_times(meson2, pwm2->hwpwm, pwm2_times);
+	if (ret) {
+		pr_err("[%s][%d]wifi: pwm_set_times filed\n",
+		       __func__, __LINE__);
+		return ret;
+	}
+	pwm_enable(pwm1);
+	pwm_enable(pwm2);
+	WIFI_INFO("wifi pwm conf ok\n");
+
+	return 0;
+}
+#endif
+
+static int wifi_dev_probe(struct platform_device *pdev)
+{
+	int ret;
+
+#ifdef CONFIG_OF
+	struct wifi_plat_info *plat;
+	const char *value;
+	//struct gpio_desc *desc;
+#else
+	struct wifi_plat_info *plat =
+	 (struct wifi_plat_info *)(pdev->dev.platform_data);
+#endif
+
+#ifdef CONFIG_OF
+	if (pdev->dev.of_node) {
+		plat = wifi_get_driver_data(pdev);
+		plat->plat_info_valid = 0;
+		plat->dev = &pdev->dev;
+
+		ret = of_property_read_string(pdev->dev.of_node,
+					      "interrupt-gpios", &value);
+		if (ret) {
+			WIFI_INFO("no interrupt pin");
+			plat->interrupt_pin = 0;
+		} else {
+			plat->interrupt_pin = of_get_named_gpio_flags
+							(pdev->dev.of_node,
+							"interrupt-gpios",
+							0, NULL);
+			ret = of_property_read_string(pdev->dev.of_node,
+						      "irq_trigger_type",
+						      &value);
+			if (ret) {
+				WIFI_INFO("no irq_trigger_type");
+				plat->irq_trigger_type = 0;
+				return -1;
+			}
+
+			if (strcmp(value, "GPIO_IRQ_HIGH") == 0) {
+				plat->irq_trigger_type = GPIO_IRQ_HIGH;
+			} else if (strcmp(value, "GPIO_IRQ_LOW") == 0) {
+				plat->irq_trigger_type = GPIO_IRQ_LOW;
+			} else if (strcmp(value, "GPIO_IRQ_RISING") == 0) {
+				plat->irq_trigger_type = GPIO_IRQ_RISING;
+			} else if (strcmp(value, "GPIO_IRQ_FALLING") == 0) {
+				plat->irq_trigger_type = GPIO_IRQ_FALLING;
+			} else {
+				WIFI_INFO("unknown irq trigger type-%s\n",
+					  value);
+				return -1;
+			}
+		}
+
+		ret = of_property_read_string(pdev->dev.of_node,
+					      "power_on-gpios", &value);
+		if (ret) {
+			WIFI_INFO("no power_on_pin");
+			plat->power_on_pin = 0;
+			plat->power_on_pin_OD = 0;
+		} else {
+			wifi_power_gpio = 1;
+			plat->power_on_pin = of_get_named_gpio_flags
+							(pdev->dev.of_node,
+							"power_on-gpios",
+							0, NULL);
+		}
+
+		ret = of_property_read_u32(pdev->dev.of_node,
+					   "power_on_pin_level",
+					   &plat->power_on_pin_level);
+
+		ret = of_property_read_u32(pdev->dev.of_node,
+					   "power_on_pin_OD",
+					   &plat->power_on_pin_OD);
+		if (ret)
+			plat->power_on_pin_OD = 0;
+		pr_info("wifi: power_on_pin_OD = %d;\n", plat->power_on_pin_OD);
+		ret = of_property_read_string(pdev->dev.of_node,
+					      "power_on_2-gpios", &value);
+		if (ret) {
+			WIFI_INFO("no power_on_pin2");
+			plat->power_on_pin2 = 0;
+		} else {
+			wifi_power_gpio2 = 1;
+			plat->power_on_pin2 = of_get_named_gpio_flags
+							(pdev->dev.of_node,
+							"power_on_2-gpios",
+							0, NULL);
+		}
+
+		ret = of_property_read_string(pdev->dev.of_node,
+					      "chip_en-gpios", &value);
+		if (ret) {
+			WIFI_INFO("no chip_en_pin");
+			plat->chip_en_pin = 0;
+		} else {
+			plat->chip_en_pin = of_get_named_gpio_flags
+							(pdev->dev.of_node,
+							"chip_en-gpios",
+							0, NULL);
+		}
+
+#ifdef CONFIG_AMLOGIC_PWM_32K
+		if (!of_get_property(pdev->dev.of_node, "disable-wifi-32k", NULL)) {
+			if (of_get_property(pdev->dev.of_node, "single_pwm", NULL)) {
+				WIFI_INFO("use single channel\n");
+				ret = pwm_single_channel_conf(plat);
+				if (ret)
+					pr_err("pwm config err\n");
+			} else {
+				WIFI_INFO("use double channel\n");
+				ret = pwm_double_channel_conf_dt(plat);
+				if (!ret)
+					pwm_double_channel_conf(plat);
+				else if (ret == -EPROBE_DEFER)
+					goto out;
+			}
+		}
+#endif
+		if (of_get_property(pdev->dev.of_node,
+				    "dhd_static_buf", NULL)) {
+			WIFI_INFO("dhd_static_buf all setup\n");
+			bcmdhd_init_wlan_mem(1);
+		} else {
+			WIFI_INFO("dhd_static_buf little setup\n");
+			bcmdhd_init_wlan_mem(0);
+		}
+
+		plat->plat_info_valid = 1;
+
+		WIFI_INFO("interrupt_pin=%d\n", plat->interrupt_pin);
+		WIFI_INFO("irq_num=%d, irq_trigger_type=%d\n",
+			  plat->irq_num, plat->irq_trigger_type);
+		WIFI_INFO("power_on_pin=%d\n", plat->power_on_pin);
+		WIFI_INFO("clock_32k_pin=%d\n", plat->clock_32k_pin);
+	}
+#endif
+	ret = alloc_chrdev_region(&wifi_power_devno,
+				  0, 1, WIFI_POWER_DRIVER_NAME);
+	if (ret < 0) {
+		ret = -ENODEV;
+		goto out;
+	}
+	ret = class_register(&wifi_power_class);
+	if (ret < 0)
+		goto error1;
+	wifi_power_cdev = cdev_alloc();
+	if (!wifi_power_cdev)
+		goto error2;
+	cdev_init(wifi_power_cdev, &wifi_power_fops);
+	wifi_power_cdev->owner = THIS_MODULE;
+	ret = cdev_add(wifi_power_cdev, wifi_power_devno, 1);
+	if (ret)
+		goto error3;
+	devp = device_create(&wifi_power_class, NULL,
+			     wifi_power_devno, NULL, WIFI_POWER_DEVICE_NAME);
+	if (IS_ERR(devp)) {
+		ret = PTR_ERR(devp);
+		goto error3;
+	}
+	devp->platform_data = pdata;
+
+	wifi_setup_dt();
+
+	wifi_dt_class = class_create(THIS_MODULE, "aml_wifi");
+	ret = class_create_file(wifi_dt_class, &class_attr_power);
+
+	//After WIFI power control driver probe, re-init WIFI power
+	set_power(0);
+	msleep(200);
+	set_power(1);
+	msleep(200);
+	sdio_reinit();
+
+
+	return 0;
+error3:
+	cdev_del(wifi_power_cdev);
+error2:
+	class_unregister(&wifi_power_class);
+error1:
+	unregister_chrdev_region(wifi_power_devno, 1);
+out:
+	return ret;
+}
+
+static int wifi_dev_remove(struct platform_device *pdev)
+{
+	WIFI_INFO("%s\n", __func__);
+	wifi_teardown_dt();
+	return 0;
+}
+
+static struct platform_driver wifi_plat_driver = {
+	.probe = wifi_dev_probe,
+	.remove = wifi_dev_remove,
+	.driver = {
+	.name = "aml_wifi",
+	.owner = THIS_MODULE,
+	.of_match_table = wifi_match
+	},
+};
+
+static int __init wifi_dt_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&wifi_plat_driver);
+	return ret;
+}
+
+/* module_init(wifi_dt_init); */
+fs_initcall_sync(wifi_dt_init);
+
+static void __exit wifi_dt_exit(void)
+{
+	platform_driver_unregister(&wifi_plat_driver);
+}
+module_exit(wifi_dt_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("AMLOGIC");
+MODULE_DESCRIPTION("wifi device tree driver");
+
+/**************** wifi mac *****************/
+u8 WIFI_MAC[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+char wifi_mac[32] = {0};
+char *wifimac;
+#ifdef MODULE
+module_param(wifimac, charp, 0644);
+#else
+core_param(wifimac, wifimac, charp, 0644);
+#endif
+static unsigned char chartonum(char c)
+{
+	if (c >= '0' && c <= '9')
+		return c - '0';
+	if (c >= 'A' && c <= 'F')
+		return (c - 'A') + 10;
+	if (c >= 'a' && c <= 'f')
+		return (c - 'a') + 10;
+	return 0;
+}
+
+static int mac_addr_set(char *line)
+{
+	unsigned char mac[6];
+	int i = 0;
+
+	WIFI_INFO("try to wifi mac from emmc key!\n");
+	for (i = 0; i < 6 && line[0] != '\0' && line[1] != '\0'; i++) {
+		mac[i] = chartonum(line[0]) << 4 | chartonum(line[1]);
+		line += 3;
+	}
+	memcpy(WIFI_MAC, mac, 6);
+	snprintf(wifi_mac, sizeof(wifi_mac),
+		 "%02x:%02x:%02x:%02x:%02x:%02x",
+		 WIFI_MAC[0], WIFI_MAC[1], WIFI_MAC[2],
+		 WIFI_MAC[3], WIFI_MAC[4], WIFI_MAC[5]);
+	wifimac = (char *)wifi_mac;
+	WIFI_INFO("uboot setup mac-addr: %x:%x:%x:%x:%x:%x\n",
+		  WIFI_MAC[0], WIFI_MAC[1], WIFI_MAC[2],
+		  WIFI_MAC[3], WIFI_MAC[4], WIFI_MAC[5]);
+
+	return 1;
+}
+
+#ifdef MODULE
+static char *mac_addr = "";
+
+static int set_mac_addr(const char *val, const struct kernel_param *kp)
+{
+	param_set_charp(val, kp);
+
+	return mac_addr_set(mac_addr);
+}
+
+static const struct kernel_param_ops mac_addr_ops = {
+	.set = set_mac_addr,
+	.get = param_get_charp,
+};
+
+module_param_cb(mac_addr, &mac_addr_ops, &mac_addr, 0644);
+MODULE_PARM_DESC(mac_addr, "mac addr");
+#else
+__setup("mac_wifi=", mac_addr_set);
+#endif
+
+u8 *wifi_get_mac(void)
+{
+	return WIFI_MAC;
+}
+EXPORT_SYMBOL(wifi_get_mac);
+
+void extern_wifi_set_enable(int is_on)
+{
+	if (is_on) {
+		set_wifi_power(1);
+		WIFI_INFO("WIFI  Enable! %d\n", wifi_info.power_on_pin);
+	} else {
+		set_wifi_power(0);
+		WIFI_INFO("WIFI  Disable! %d\n", wifi_info.power_on_pin);
+	}
+}
+EXPORT_SYMBOL(extern_wifi_set_enable);
+
+int wifi_irq_num(void)
+{
+	return wifi_info.irq_num;
+}
+EXPORT_SYMBOL(wifi_irq_num);
+
+int wifi_irq_trigger_level(void)
+{
+	return wifi_info.irq_trigger_type;
+}
+EXPORT_SYMBOL(wifi_irq_trigger_level);
+MODULE_DESCRIPTION("Amlogic S912/wifi driver");
+MODULE_AUTHOR("Kevin Hilman <khilman@baylibre.com>");
+MODULE_LICENSE("GPL");
diff -urN linux-5.10.y-a/drivers/base/dd.c linux-5.10.y-b/drivers/base/dd.c
--- linux-5.10.y-a/drivers/base/dd.c	2023-06-30 15:33:52.173696818 +0800
+++ linux-5.10.y-b/drivers/base/dd.c	2022-12-25 17:04:50.000000000 +0800
@@ -501,6 +501,7 @@
 	bool test_remove = IS_ENABLED(CONFIG_DEBUG_TEST_DRIVER_REMOVE) &&
 			   !drv->suppress_bind_attrs;
 
+	pr_warn("%s: really_probe\n", drv->name);
 	if (defer_all_probes) {
 		/*
 		 * Value of defer_all_probes can be set only by
@@ -532,13 +533,16 @@
 
 	/* If using pinctrl, bind pins now before probing */
 	ret = pinctrl_bind_pins(dev);
+	pr_warn("%s: really_probe pinctrl_bind_pins ret:%d\n", drv->name,ret);
 	if (ret)
 		goto pinctrl_bind_failed;
 
 	if (dev->bus->dma_configure) {
 		ret = dev->bus->dma_configure(dev);
-		if (ret)
+		if (ret){
+			pr_warn("%s: really_probe dma_configure ret:%d\n", drv->name,ret);
 			goto probe_failed;
+		}
 	}
 
 	ret = driver_sysfs_add(dev);
@@ -550,23 +554,30 @@
 
 	if (dev->pm_domain && dev->pm_domain->activate) {
 		ret = dev->pm_domain->activate(dev);
-		if (ret)
+		if (ret){
+			pr_warn("%s: really_probe pm_domain activate ret:%d\n", drv->name,ret);
 			goto probe_failed;
+		}
 	}
 
 	if (dev->bus->probe) {
 		ret = dev->bus->probe(dev);
-		if (ret)
+		if (ret){
+			pr_warn("%s: bus:%s really_probe bus->probe ret:%d\n", drv->name,dev->bus->name, ret);
 			goto probe_failed;
+		}
 	} else if (drv->probe) {
 		ret = drv->probe(dev);
-		if (ret)
+		if (ret){
+			pr_warn("%s: really_probe drv->probe ret:%d\n", drv->name,ret);
 			goto probe_failed;
+		}
 	}
 
 	ret = device_add_groups(dev, drv->dev_groups);
 	if (ret) {
 		dev_err(dev, "device_add_groups() failed\n");
+		pr_warn("%s: really_probe device_add_groups ret:%d\n", drv->name,ret);
 		goto dev_groups_failed;
 	}
 
@@ -574,6 +585,7 @@
 		ret = device_create_file(dev, &dev_attr_state_synced);
 		if (ret) {
 			dev_err(dev, "state_synced sysfs add failed\n");
+			pr_warn("%s: really_probe sysfs add ret:%d\n", drv->name,ret);
 			goto dev_sysfs_state_synced_failed;
 		}
 	}
@@ -599,10 +611,10 @@
 		if (dev->pm_domain && dev->pm_domain->dismiss)
 			dev->pm_domain->dismiss(dev);
 		pm_runtime_reinit(dev);
-
+		pr_warn("%s: really_probe test_remove\n", drv->name);
 		goto re_probe;
 	}
-
+	pr_warn("%s: really_probe pinctrl_init_done\n", drv->name);
 	pinctrl_init_done(dev);
 
 	if (dev->pm_domain && dev->pm_domain->sync)
@@ -677,12 +689,7 @@
 	calltime = ktime_get();
 	ret = really_probe(dev, drv);
 	rettime = ktime_get();
-	/*
-	 * Don't change this to pr_debug() because that requires
-	 * CONFIG_DYNAMIC_DEBUG and we want a simple 'initcall_debug' on the
-	 * kernel commandline to print this all the time at the debug level.
-	 */
-	printk(KERN_DEBUG "probe of %s returned %d after %lld usecs\n",
+	pr_debug("probe of %s returned %d after %lld usecs\n",
 		 dev_name(dev), ret, ktime_us_delta(rettime, calltime));
 	return ret;
 }
@@ -1093,11 +1100,7 @@
 		return 0;
 	} else if (ret < 0) {
 		dev_dbg(dev, "Bus failed to match device: %d\n", ret);
-		/*
-		 * Driver could not match with device, but may match with
-		 * another device on the bus.
-		 */
-		return 0;
+		return ret;
 	} /* ret > 0 means positive match */
 
 	if (driver_allows_async_probing(drv)) {
diff -urN linux-5.10.y-a/drivers/Kconfig linux-5.10.y-b/drivers/Kconfig
--- linux-5.10.y-a/drivers/Kconfig	2023-06-30 15:33:27.033314100 +0800
+++ linux-5.10.y-b/drivers/Kconfig	2022-12-21 07:30:00.000000000 +0800
@@ -235,4 +235,6 @@
 source "drivers/counter/Kconfig"
 
 source "drivers/most/Kconfig"
+
+source "drivers/amlogic/Kconfig"
 endmenu
diff -urN linux-5.10.y-a/drivers/Makefile linux-5.10.y-b/drivers/Makefile
--- linux-5.10.y-a/drivers/Makefile	2023-06-30 15:33:39.225499555 +0800
+++ linux-5.10.y-b/drivers/Makefile	2022-12-21 07:30:18.000000000 +0800
@@ -189,3 +189,5 @@
 obj-$(CONFIG_INTERCONNECT)	+= interconnect/
 obj-$(CONFIG_COUNTER)		+= counter/
 obj-$(CONFIG_MOST)		+= most/
+
+obj-$(CONFIG_AMLOGIC_MODIFY)	+= amlogic/
\ No newline at end of file
diff -urN linux-5.10.y-a/drivers/mmc/core/block.c linux-5.10.y-b/drivers/mmc/core/block.c
--- linux-5.10.y-a/drivers/mmc/core/block.c	2023-06-30 15:39:09.775475669 +0800
+++ linux-5.10.y-b/drivers/mmc/core/block.c	2023-01-30 10:58:54.000000000 +0800
@@ -253,7 +253,6 @@
 		goto out_put;
 	}
 	req_to_mmc_queue_req(req)->drv_op = MMC_DRV_OP_BOOT_WP;
-	req_to_mmc_queue_req(req)->drv_op_result = -EIO;
 	blk_execute_rq(mq->queue, NULL, req, 0);
 	ret = req_to_mmc_queue_req(req)->drv_op_result;
 	blk_put_request(req);
@@ -639,7 +638,6 @@
 	idatas[0] = idata;
 	req_to_mmc_queue_req(req)->drv_op =
 		rpmb ? MMC_DRV_OP_IOCTL_RPMB : MMC_DRV_OP_IOCTL;
-	req_to_mmc_queue_req(req)->drv_op_result = -EIO;
 	req_to_mmc_queue_req(req)->drv_op_data = idatas;
 	req_to_mmc_queue_req(req)->ioc_count = 1;
 	blk_execute_rq(mq->queue, NULL, req, 0);
@@ -709,7 +707,6 @@
 	}
 	req_to_mmc_queue_req(req)->drv_op =
 		rpmb ? MMC_DRV_OP_IOCTL_RPMB : MMC_DRV_OP_IOCTL;
-	req_to_mmc_queue_req(req)->drv_op_result = -EIO;
 	req_to_mmc_queue_req(req)->drv_op_data = idata;
 	req_to_mmc_queue_req(req)->ioc_count = num_of_cmds;
 	blk_execute_rq(mq->queue, NULL, req, 0);
@@ -2752,7 +2749,6 @@
 	if (IS_ERR(req))
 		return PTR_ERR(req);
 	req_to_mmc_queue_req(req)->drv_op = MMC_DRV_OP_GET_CARD_STATUS;
-	req_to_mmc_queue_req(req)->drv_op_result = -EIO;
 	blk_execute_rq(mq->queue, NULL, req, 0);
 	ret = req_to_mmc_queue_req(req)->drv_op_result;
 	if (ret >= 0) {
@@ -2791,7 +2787,6 @@
 		goto out_free;
 	}
 	req_to_mmc_queue_req(req)->drv_op = MMC_DRV_OP_GET_EXT_CSD;
-	req_to_mmc_queue_req(req)->drv_op_result = -EIO;
 	req_to_mmc_queue_req(req)->drv_op_data = &ext_csd;
 	blk_execute_rq(mq->queue, NULL, req, 0);
 	err = req_to_mmc_queue_req(req)->drv_op_result;
diff -urN linux-5.10.y-a/drivers/mmc/core/core.c linux-5.10.y-b/drivers/mmc/core/core.c
--- linux-5.10.y-a/drivers/mmc/core/core.c	2023-06-30 15:39:09.711478316 +0800
+++ linux-5.10.y-b/drivers/mmc/core/core.c	2023-01-30 11:00:10.000000000 +0800
@@ -394,6 +394,7 @@
 	return err;
 }
 
+#if 0
 void mmc_wait_for_req_done(struct mmc_host *host, struct mmc_request *mrq)
 {
 	struct mmc_command *cmd;
@@ -418,6 +419,49 @@
 
 	mmc_retune_release(host);
 }
+#else
+void mmc_wait_for_req_done(struct mmc_host *host, struct mmc_request *mrq)
+{
+	struct mmc_command *cmd;
+
+	while (1) {
+		wait_for_completion(&mrq->completion);
+
+		cmd = mrq->cmd;
+
+		/*
+		 * If host has timed out waiting for the sanitize
+		 * to complete, card might be still in programming state
+		 * so let's try to bring the card out of programming
+		 * state.
+		 */
+		if (cmd->sanitize_busy && cmd->error == -ETIMEDOUT) {
+			if (!mmc_interrupt_hpi(host->card)) {
+				pr_warn("%s: %s: Interrupted sanitize\n",
+					mmc_hostname(host), __func__);
+				cmd->error = 0;
+				break;
+			} else {
+				pr_err("%s: %s: Failed to interrupt sanitize\n",
+				       mmc_hostname(host), __func__);
+			}
+		}
+		if (!cmd->error || !cmd->retries ||
+		    mmc_card_removed(host->card))
+			break;
+
+		mmc_retune_recheck(host);
+
+		pr_debug("%s: req failed (CMD%u): %d, retrying...\n",
+			 mmc_hostname(host), cmd->opcode, cmd->error);
+		cmd->retries--;
+		cmd->error = 0;
+		__mmc_start_request(host, mrq);
+	}
+
+	mmc_retune_release(host);
+}
+#endif
 EXPORT_SYMBOL(mmc_wait_for_req_done);
 
 /*
diff -urN linux-5.10.y-a/drivers/mmc/core/host.h linux-5.10.y-b/drivers/mmc/core/host.h
--- linux-5.10.y-a/drivers/mmc/core/host.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/drivers/mmc/core/host.h	2023-01-01 12:09:38.000000000 +0800
@@ -0,0 +1,81 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ *  linux/drivers/mmc/core/host.h
+ *
+ *  Copyright (C) 2003 Russell King, All Rights Reserved.
+ *  Copyright 2007 Pierre Ossman
+ */
+#ifndef _MMC_CORE_HOST_H
+#define _MMC_CORE_HOST_H
+
+#include <linux/mmc/host.h>
+
+int mmc_register_host_class(void);
+void mmc_unregister_host_class(void);
+
+void mmc_retune_enable(struct mmc_host *host);
+void mmc_retune_disable(struct mmc_host *host);
+void mmc_retune_hold(struct mmc_host *host);
+void mmc_retune_release(struct mmc_host *host);
+int mmc_retune(struct mmc_host *host);
+void mmc_retune_pause(struct mmc_host *host);
+void mmc_retune_unpause(struct mmc_host *host);
+
+static inline void mmc_retune_hold_now(struct mmc_host *host)
+{
+	host->retune_now = 0;
+	host->hold_retune += 1;
+}
+
+static inline void mmc_retune_recheck(struct mmc_host *host)
+{
+	if (host->hold_retune <= 1)
+		host->retune_now = 1;
+}
+
+static inline int mmc_host_cmd23(struct mmc_host *host)
+{
+	return host->caps & MMC_CAP_CMD23;
+}
+
+static inline bool mmc_host_done_complete(struct mmc_host *host)
+{
+	return host->caps & MMC_CAP_DONE_COMPLETE;
+}
+
+static inline int mmc_boot_partition_access(struct mmc_host *host)
+{
+	return !(host->caps2 & MMC_CAP2_BOOTPART_NOACC);
+}
+
+static inline int mmc_host_uhs(struct mmc_host *host)
+{
+	return host->caps &
+		(MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
+		 MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 |
+		 MMC_CAP_UHS_DDR50) &&
+	       host->caps & MMC_CAP_4_BIT_DATA;
+}
+
+static inline bool mmc_card_hs200(struct mmc_card *card)
+{
+	return card->host->ios.timing == MMC_TIMING_MMC_HS200;
+}
+
+static inline bool mmc_card_ddr52(struct mmc_card *card)
+{
+	return card->host->ios.timing == MMC_TIMING_MMC_DDR52;
+}
+
+static inline bool mmc_card_hs400(struct mmc_card *card)
+{
+	return card->host->ios.timing == MMC_TIMING_MMC_HS400;
+}
+
+static inline bool mmc_card_hs400es(struct mmc_card *card)
+{
+	return card->host->ios.enhanced_strobe;
+}
+
+#endif
+
diff -urN linux-5.10.y-a/drivers/mmc/core/mmc_ops.c linux-5.10.y-b/drivers/mmc/core/mmc_ops.c
--- linux-5.10.y-a/drivers/mmc/core/mmc_ops.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/drivers/mmc/core/mmc_ops.c	2023-01-03 16:51:32.000000000 +0800
@@ -0,0 +1,1067 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ *  linux/drivers/mmc/core/mmc_ops.h
+ *
+ *  Copyright 2006-2007 Pierre Ossman
+ */
+
+#include <linux/slab.h>
+#include <linux/export.h>
+#include <linux/types.h>
+#include <linux/scatterlist.h>
+
+#include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/mmc.h>
+
+#include "core.h"
+#include "card.h"
+#include "host.h"
+#include "mmc_ops.h"
+
+#define MMC_BKOPS_TIMEOUT_MS		(120 * 1000) /* 120s */
+#define MMC_CACHE_FLUSH_TIMEOUT_MS	(30 * 1000) /* 30s */
+#define MMC_SANITIZE_TIMEOUT_MS		(240 * 1000) /* 240s */
+
+static const u8 tuning_blk_pattern_4bit[] = {
+	0xff, 0x0f, 0xff, 0x00, 0xff, 0xcc, 0xc3, 0xcc,
+	0xc3, 0x3c, 0xcc, 0xff, 0xfe, 0xff, 0xfe, 0xef,
+	0xff, 0xdf, 0xff, 0xdd, 0xff, 0xfb, 0xff, 0xfb,
+	0xbf, 0xff, 0x7f, 0xff, 0x77, 0xf7, 0xbd, 0xef,
+	0xff, 0xf0, 0xff, 0xf0, 0x0f, 0xfc, 0xcc, 0x3c,
+	0xcc, 0x33, 0xcc, 0xcf, 0xff, 0xef, 0xff, 0xee,
+	0xff, 0xfd, 0xff, 0xfd, 0xdf, 0xff, 0xbf, 0xff,
+	0xbb, 0xff, 0xf7, 0xff, 0xf7, 0x7f, 0x7b, 0xde,
+};
+
+static const u8 tuning_blk_pattern_8bit[] = {
+	0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,
+	0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc, 0xcc,
+	0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff, 0xff,
+	0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee, 0xff,
+	0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd, 0xdd,
+	0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff, 0xbb,
+	0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff, 0xff,
+	0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee, 0xff,
+	0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
+	0x00, 0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc,
+	0xcc, 0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff,
+	0xff, 0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee,
+	0xff, 0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd,
+	0xdd, 0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff,
+	0xbb, 0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff,
+	0xff, 0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee,
+};
+
+int __mmc_send_status(struct mmc_card *card, u32 *status, unsigned int retries)
+{
+	int err;
+	struct mmc_command cmd = {};
+
+	cmd.opcode = MMC_SEND_STATUS;
+	if (!mmc_host_is_spi(card->host))
+		cmd.arg = card->rca << 16;
+	cmd.flags = MMC_RSP_SPI_R2 | MMC_RSP_R1 | MMC_CMD_AC;
+
+	err = mmc_wait_for_cmd(card->host, &cmd, retries);
+	if (err)
+		return err;
+
+	/* NOTE: callers are required to understand the difference
+	 * between "native" and SPI format status words!
+	 */
+	if (status)
+		*status = cmd.resp[0];
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(__mmc_send_status);
+
+int mmc_send_status(struct mmc_card *card, u32 *status)
+{
+	return __mmc_send_status(card, status, MMC_CMD_RETRIES);
+}
+EXPORT_SYMBOL_GPL(mmc_send_status);
+
+static int _mmc_select_card(struct mmc_host *host, struct mmc_card *card)
+{
+	struct mmc_command cmd = {};
+
+	cmd.opcode = MMC_SELECT_CARD;
+
+	if (card) {
+		cmd.arg = card->rca << 16;
+		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+	} else {
+		cmd.arg = 0;
+		cmd.flags = MMC_RSP_NONE | MMC_CMD_AC;
+	}
+
+	return mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);
+}
+
+int mmc_select_card(struct mmc_card *card)
+{
+
+	return _mmc_select_card(card->host, card);
+}
+
+int mmc_deselect_cards(struct mmc_host *host)
+{
+	return _mmc_select_card(host, NULL);
+}
+
+/*
+ * Write the value specified in the device tree or board code into the optional
+ * 16 bit Driver Stage Register. This can be used to tune raise/fall times and
+ * drive strength of the DAT and CMD outputs. The actual meaning of a given
+ * value is hardware dependant.
+ * The presence of the DSR register can be determined from the CSD register,
+ * bit 76.
+ */
+int mmc_set_dsr(struct mmc_host *host)
+{
+	struct mmc_command cmd = {};
+
+	cmd.opcode = MMC_SET_DSR;
+
+	cmd.arg = (host->dsr << 16) | 0xffff;
+	cmd.flags = MMC_RSP_NONE | MMC_CMD_AC;
+
+	return mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);
+}
+
+int mmc_go_idle(struct mmc_host *host)
+{
+	int err;
+	struct mmc_command cmd = {};
+
+	/*
+	 * Non-SPI hosts need to prevent chipselect going active during
+	 * GO_IDLE; that would put chips into SPI mode.  Remind them of
+	 * that in case of hardware that won't pull up DAT3/nCS otherwise.
+	 *
+	 * SPI hosts ignore ios.chip_select; it's managed according to
+	 * rules that must accommodate non-MMC slaves which this layer
+	 * won't even know about.
+	 */
+	if (!mmc_host_is_spi(host)) {
+		mmc_set_chip_select(host, MMC_CS_HIGH);
+		mmc_delay(1);
+	}
+
+	cmd.opcode = MMC_GO_IDLE_STATE;
+	cmd.arg = 0;
+	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_NONE | MMC_CMD_BC;
+
+	err = mmc_wait_for_cmd(host, &cmd, 0);
+
+	mmc_delay(1);
+
+	if (!mmc_host_is_spi(host)) {
+		mmc_set_chip_select(host, MMC_CS_DONTCARE);
+		mmc_delay(1);
+	}
+
+	host->use_spi_crc = 0;
+
+	return err;
+}
+
+int mmc_send_op_cond(struct mmc_host *host, u32 ocr, u32 *rocr)
+{
+	struct mmc_command cmd = {};
+	int i, err = 0;
+
+	cmd.opcode = MMC_SEND_OP_COND;
+	cmd.arg = mmc_host_is_spi(host) ? 0 : ocr;
+	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R3 | MMC_CMD_BCR;
+
+	for (i = 100; i; i--) {
+		err = mmc_wait_for_cmd(host, &cmd, 0);
+		if (err)
+			break;
+
+		/* wait until reset completes */
+		if (mmc_host_is_spi(host)) {
+			if (!(cmd.resp[0] & R1_SPI_IDLE))
+				break;
+		} else {
+			if (cmd.resp[0] & MMC_CARD_BUSY)
+				break;
+		}
+
+		err = -ETIMEDOUT;
+
+		mmc_delay(10);
+
+		/*
+		 * According to eMMC specification v5.1 section 6.4.3, we
+		 * should issue CMD1 repeatedly in the idle state until
+		 * the eMMC is ready. Otherwise some eMMC devices seem to enter
+		 * the inactive mode after mmc_init_card() issued CMD0 when
+		 * the eMMC device is busy.
+		 */
+		if (!ocr && !mmc_host_is_spi(host))
+			cmd.arg = cmd.resp[0] | BIT(30);
+	}
+
+	if (rocr && !mmc_host_is_spi(host))
+		*rocr = cmd.resp[0];
+
+	return err;
+}
+
+int mmc_set_relative_addr(struct mmc_card *card)
+{
+	struct mmc_command cmd = {};
+
+	cmd.opcode = MMC_SET_RELATIVE_ADDR;
+	cmd.arg = card->rca << 16;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+
+	return mmc_wait_for_cmd(card->host, &cmd, MMC_CMD_RETRIES);
+}
+
+static int
+mmc_send_cxd_native(struct mmc_host *host, u32 arg, u32 *cxd, int opcode)
+{
+	int err;
+	struct mmc_command cmd = {};
+
+	cmd.opcode = opcode;
+	cmd.arg = arg;
+	cmd.flags = MMC_RSP_R2 | MMC_CMD_AC;
+
+	err = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);
+	if (err)
+		return err;
+
+	memcpy(cxd, cmd.resp, sizeof(u32) * 4);
+
+	return 0;
+}
+
+/*
+ * NOTE: void *buf, caller for the buf is required to use DMA-capable
+ * buffer or on-stack buffer (with some overhead in callee).
+ */
+static int
+mmc_send_cxd_data(struct mmc_card *card, struct mmc_host *host,
+		u32 opcode, void *buf, unsigned len)
+{
+	struct mmc_request mrq = {};
+	struct mmc_command cmd = {};
+	struct mmc_data data = {};
+	struct scatterlist sg;
+
+	mrq.cmd = &cmd;
+	mrq.data = &data;
+
+	cmd.opcode = opcode;
+	cmd.arg = 0;
+
+	/* NOTE HACK:  the MMC_RSP_SPI_R1 is always correct here, but we
+	 * rely on callers to never use this with "native" calls for reading
+	 * CSD or CID.  Native versions of those commands use the R2 type,
+	 * not R1 plus a data block.
+	 */
+	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;
+
+	data.blksz = len;
+	data.blocks = 1;
+	data.flags = MMC_DATA_READ;
+	data.sg = &sg;
+	data.sg_len = 1;
+
+	sg_init_one(&sg, buf, len);
+
+	if (opcode == MMC_SEND_CSD || opcode == MMC_SEND_CID) {
+		/*
+		 * The spec states that CSR and CID accesses have a timeout
+		 * of 64 clock cycles.
+		 */
+		data.timeout_ns = 0;
+		data.timeout_clks = 64;
+	} else
+		mmc_set_data_timeout(&data, card);
+
+	mmc_wait_for_req(host, &mrq);
+
+	if (cmd.error)
+		return cmd.error;
+	if (data.error)
+		return data.error;
+
+	return 0;
+}
+
+static int mmc_spi_send_csd(struct mmc_card *card, u32 *csd)
+{
+	int ret, i;
+	__be32 *csd_tmp;
+
+	csd_tmp = kzalloc(16, GFP_KERNEL);
+	if (!csd_tmp)
+		return -ENOMEM;
+
+	ret = mmc_send_cxd_data(card, card->host, MMC_SEND_CSD, csd_tmp, 16);
+	if (ret)
+		goto err;
+
+	for (i = 0; i < 4; i++)
+		csd[i] = be32_to_cpu(csd_tmp[i]);
+
+err:
+	kfree(csd_tmp);
+	return ret;
+}
+
+int mmc_send_csd(struct mmc_card *card, u32 *csd)
+{
+	if (mmc_host_is_spi(card->host))
+		return mmc_spi_send_csd(card, csd);
+
+	return mmc_send_cxd_native(card->host, card->rca << 16,	csd,
+				MMC_SEND_CSD);
+}
+
+static int mmc_spi_send_cid(struct mmc_host *host, u32 *cid)
+{
+	int ret, i;
+	__be32 *cid_tmp;
+
+	cid_tmp = kzalloc(16, GFP_KERNEL);
+	if (!cid_tmp)
+		return -ENOMEM;
+
+	ret = mmc_send_cxd_data(NULL, host, MMC_SEND_CID, cid_tmp, 16);
+	if (ret)
+		goto err;
+
+	for (i = 0; i < 4; i++)
+		cid[i] = be32_to_cpu(cid_tmp[i]);
+
+err:
+	kfree(cid_tmp);
+	return ret;
+}
+
+int mmc_send_cid(struct mmc_host *host, u32 *cid)
+{
+	if (mmc_host_is_spi(host))
+		return mmc_spi_send_cid(host, cid);
+
+	return mmc_send_cxd_native(host, 0, cid, MMC_ALL_SEND_CID);
+}
+
+int mmc_get_ext_csd(struct mmc_card *card, u8 **new_ext_csd)
+{
+	int err;
+	u8 *ext_csd;
+
+	if (!card || !new_ext_csd)
+		return -EINVAL;
+
+	if (!mmc_can_ext_csd(card))
+		return -EOPNOTSUPP;
+
+	/*
+	 * As the ext_csd is so large and mostly unused, we don't store the
+	 * raw block in mmc_card.
+	 */
+	ext_csd = kzalloc(512, GFP_KERNEL);
+	if (!ext_csd)
+		return -ENOMEM;
+
+	err = mmc_send_cxd_data(card, card->host, MMC_SEND_EXT_CSD, ext_csd,
+				512);
+	if (err)
+		kfree(ext_csd);
+	else
+		*new_ext_csd = ext_csd;
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(mmc_get_ext_csd);
+
+int mmc_spi_read_ocr(struct mmc_host *host, int highcap, u32 *ocrp)
+{
+	struct mmc_command cmd = {};
+	int err;
+
+	cmd.opcode = MMC_SPI_READ_OCR;
+	cmd.arg = highcap ? (1 << 30) : 0;
+	cmd.flags = MMC_RSP_SPI_R3;
+
+	err = mmc_wait_for_cmd(host, &cmd, 0);
+
+	*ocrp = cmd.resp[1];
+	return err;
+}
+
+int mmc_spi_set_crc(struct mmc_host *host, int use_crc)
+{
+	struct mmc_command cmd = {};
+	int err;
+
+	cmd.opcode = MMC_SPI_CRC_ON_OFF;
+	cmd.flags = MMC_RSP_SPI_R1;
+	cmd.arg = use_crc;
+
+	err = mmc_wait_for_cmd(host, &cmd, 0);
+	if (!err)
+		host->use_spi_crc = use_crc;
+	return err;
+}
+
+static int mmc_switch_status_error(struct mmc_host *host, u32 status)
+{
+	if (mmc_host_is_spi(host)) {
+		if (status & R1_SPI_ILLEGAL_COMMAND)
+			return -EBADMSG;
+	} else {
+		if (R1_STATUS(status))
+			pr_warn("%s: unexpected status %#x after switch\n",
+				mmc_hostname(host), status);
+		if (status & R1_SWITCH_ERROR)
+			return -EBADMSG;
+	}
+	return 0;
+}
+
+/* Caller must hold re-tuning */
+int mmc_switch_status(struct mmc_card *card, bool crc_err_fatal)
+{
+	u32 status;
+	int err;
+
+	err = mmc_send_status(card, &status);
+	if (!crc_err_fatal && err == -EILSEQ)
+		return 0;
+	if (err)
+		return err;
+
+	return mmc_switch_status_error(card->host, status);
+}
+
+static int mmc_busy_status(struct mmc_card *card, bool retry_crc_err,
+			   enum mmc_busy_cmd busy_cmd, bool *busy)
+{
+	struct mmc_host *host = card->host;
+	u32 status = 0;
+	int err;
+
+	if (host->ops->card_busy) {
+		*busy = host->ops->card_busy(host);
+		return 0;
+	}
+
+	err = mmc_send_status(card, &status);
+	if (retry_crc_err && err == -EILSEQ) {
+		*busy = true;
+		return 0;
+	}
+	if (err)
+		return err;
+
+	switch (busy_cmd) {
+	case MMC_BUSY_CMD6:
+		err = mmc_switch_status_error(card->host, status);
+		break;
+	case MMC_BUSY_ERASE:
+		err = R1_STATUS(status) ? -EIO : 0;
+		break;
+	case MMC_BUSY_HPI:
+		break;
+	default:
+		err = -EINVAL;
+	}
+
+	if (err)
+		return err;
+
+	*busy = !mmc_ready_for_data(status);
+	return 0;
+}
+
+static int __mmc_poll_for_busy(struct mmc_card *card, unsigned int timeout_ms,
+			       bool send_status, bool retry_crc_err,
+			       enum mmc_busy_cmd busy_cmd)
+{
+	struct mmc_host *host = card->host;
+	int err;
+	unsigned long timeout;
+	unsigned int udelay = 32, udelay_max = 32768;
+	bool expired = false;
+	bool busy = false;
+
+	/*
+	 * In cases when not allowed to poll by using CMD13 or because we aren't
+	 * capable of polling by using ->card_busy(), then rely on waiting the
+	 * stated timeout to be sufficient.
+	 */
+	if (!send_status && !host->ops->card_busy) {
+		mmc_delay(timeout_ms);
+		return 0;
+	}
+
+	timeout = jiffies + msecs_to_jiffies(timeout_ms) + 1;
+	do {
+		/*
+		 * Due to the possibility of being preempted while polling,
+		 * check the expiration time first.
+		 */
+		expired = time_after(jiffies, timeout);
+
+		err = mmc_busy_status(card, retry_crc_err, busy_cmd, &busy);
+		if (err)
+			return err;
+
+		/* Timeout if the device still remains busy. */
+		if (expired && busy) {
+			pr_err("%s: Card stuck being busy! %s\n",
+				mmc_hostname(host), __func__);
+			return -ETIMEDOUT;
+		}
+
+		/* Throttle the polling rate to avoid hogging the CPU. */
+		if (busy) {
+			usleep_range(udelay, udelay * 2);
+			if (udelay < udelay_max)
+				udelay *= 2;
+		}
+	} while (busy);
+
+	return 0;
+}
+
+int mmc_poll_for_busy(struct mmc_card *card, unsigned int timeout_ms,
+		      enum mmc_busy_cmd busy_cmd)
+{
+	return __mmc_poll_for_busy(card, timeout_ms, true, false, busy_cmd);
+}
+
+/**
+ *	__mmc_switch - modify EXT_CSD register
+ *	@card: the MMC card associated with the data transfer
+ *	@set: cmd set values
+ *	@index: EXT_CSD register index
+ *	@value: value to program into EXT_CSD register
+ *	@timeout_ms: timeout (ms) for operation performed by register write,
+ *                   timeout of zero implies maximum possible timeout
+ *	@timing: new timing to change to
+ *	@send_status: send status cmd to poll for busy
+ *	@retry_crc_err: retry when CRC errors when polling with CMD13 for busy
+ *
+ *	Modifies the EXT_CSD register for selected card.
+ */
+int __mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value,
+		unsigned int timeout_ms, unsigned char timing,
+		bool send_status, bool retry_crc_err)
+{
+	struct mmc_host *host = card->host;
+	int err;
+	struct mmc_command cmd = {};
+	bool use_r1b_resp = true;
+	unsigned char old_timing = host->ios.timing;
+
+	mmc_retune_hold(host);
+
+	if (!timeout_ms) {
+		pr_warn("%s: unspecified timeout for CMD6 - use generic\n",
+			mmc_hostname(host));
+		timeout_ms = card->ext_csd.generic_cmd6_time;
+	}
+
+	/*
+	 * If the max_busy_timeout of the host is specified, make sure it's
+	 * enough to fit the used timeout_ms. In case it's not, let's instruct
+	 * the host to avoid HW busy detection, by converting to a R1 response
+	 * instead of a R1B. Note, some hosts requires R1B, which also means
+	 * they are on their own when it comes to deal with the busy timeout.
+	 */
+	if (!(host->caps & MMC_CAP_NEED_RSP_BUSY) && host->max_busy_timeout &&
+	    (timeout_ms > host->max_busy_timeout))
+		use_r1b_resp = false;
+
+	cmd.opcode = MMC_SWITCH;
+	cmd.arg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
+		  (index << 16) |
+		  (value << 8) |
+		  set;
+	cmd.flags = MMC_CMD_AC;
+	if (use_r1b_resp) {
+		cmd.flags |= MMC_RSP_SPI_R1B | MMC_RSP_R1B;
+		cmd.busy_timeout = timeout_ms;
+	} else {
+		cmd.flags |= MMC_RSP_SPI_R1 | MMC_RSP_R1;
+	}
+
+	if (index == EXT_CSD_SANITIZE_START)
+		cmd.sanitize_busy = true;
+
+	err = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);
+	if (err)
+		goto out;
+
+	/*If SPI or used HW busy detection above, then we don't need to poll. */
+	if (((host->caps & MMC_CAP_WAIT_WHILE_BUSY) && use_r1b_resp) ||
+		mmc_host_is_spi(host))
+		goto out_tim;
+
+	/* Let's try to poll to find out when the command is completed. */
+	err = __mmc_poll_for_busy(card, timeout_ms, send_status, retry_crc_err,
+				  MMC_BUSY_CMD6);
+	if (err)
+		goto out;
+
+out_tim:
+	/* Switch to new timing before check switch status. */
+	if (timing)
+		mmc_set_timing(host, timing);
+
+	if (send_status) {
+		err = mmc_switch_status(card, true);
+		if (err && timing)
+			mmc_set_timing(host, old_timing);
+	}
+out:
+	mmc_retune_release(host);
+
+	return err;
+}
+
+int mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value,
+		unsigned int timeout_ms)
+{
+	return __mmc_switch(card, set, index, value, timeout_ms, 0,
+			    true, false);
+}
+EXPORT_SYMBOL_GPL(mmc_switch);
+
+int mmc_send_tuning(struct mmc_host *host, u32 opcode, int *cmd_error)
+{
+	struct mmc_request mrq = {};
+	struct mmc_command cmd = {};
+	struct mmc_data data = {};
+	struct scatterlist sg;
+	struct mmc_ios *ios = &host->ios;
+	const u8 *tuning_block_pattern;
+	int size, err = 0;
+	u8 *data_buf;
+
+	if (ios->bus_width == MMC_BUS_WIDTH_8) {
+		tuning_block_pattern = tuning_blk_pattern_8bit;
+		size = sizeof(tuning_blk_pattern_8bit);
+	} else if (ios->bus_width == MMC_BUS_WIDTH_4) {
+		tuning_block_pattern = tuning_blk_pattern_4bit;
+		size = sizeof(tuning_blk_pattern_4bit);
+	} else
+		return -EINVAL;
+
+	data_buf = kzalloc(size, GFP_KERNEL);
+	if (!data_buf)
+		return -ENOMEM;
+
+	mrq.cmd = &cmd;
+	mrq.data = &data;
+
+	cmd.opcode = opcode;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
+
+	data.blksz = size;
+	data.blocks = 1;
+	data.flags = MMC_DATA_READ;
+
+	/*
+	 * According to the tuning specs, Tuning process
+	 * is normally shorter 40 executions of CMD19,
+	 * and timeout value should be shorter than 150 ms
+	 */
+	data.timeout_ns = 150 * NSEC_PER_MSEC;
+
+	data.sg = &sg;
+	data.sg_len = 1;
+	sg_init_one(&sg, data_buf, size);
+
+	mmc_wait_for_req(host, &mrq);
+
+	if (cmd_error)
+		*cmd_error = cmd.error;
+
+	if (cmd.error) {
+		err = cmd.error;
+		goto out;
+	}
+
+	if (data.error) {
+		err = data.error;
+		goto out;
+	}
+
+	if (memcmp(data_buf, tuning_block_pattern, size))
+		err = -EIO;
+
+out:
+	kfree(data_buf);
+	return err;
+}
+EXPORT_SYMBOL_GPL(mmc_send_tuning);
+
+int mmc_abort_tuning(struct mmc_host *host, u32 opcode)
+{
+	struct mmc_command cmd = {};
+
+	/*
+	 * eMMC specification specifies that CMD12 can be used to stop a tuning
+	 * command, but SD specification does not, so do nothing unless it is
+	 * eMMC.
+	 */
+	if (opcode != MMC_SEND_TUNING_BLOCK_HS200)
+		return 0;
+
+	cmd.opcode = MMC_STOP_TRANSMISSION;
+	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;
+
+	/*
+	 * For drivers that override R1 to R1b, set an arbitrary timeout based
+	 * on the tuning timeout i.e. 150ms.
+	 */
+	cmd.busy_timeout = 150;
+
+	return mmc_wait_for_cmd(host, &cmd, 0);
+}
+EXPORT_SYMBOL_GPL(mmc_abort_tuning);
+
+static int
+mmc_send_bus_test(struct mmc_card *card, struct mmc_host *host, u8 opcode,
+		  u8 len)
+{
+	struct mmc_request mrq = {};
+	struct mmc_command cmd = {};
+	struct mmc_data data = {};
+	struct scatterlist sg;
+	u8 *data_buf;
+	u8 *test_buf;
+	int i, err;
+	static u8 testdata_8bit[8] = { 0x55, 0xaa, 0, 0, 0, 0, 0, 0 };
+	static u8 testdata_4bit[4] = { 0x5a, 0, 0, 0 };
+
+	/* dma onto stack is unsafe/nonportable, but callers to this
+	 * routine normally provide temporary on-stack buffers ...
+	 */
+	data_buf = kmalloc(len, GFP_KERNEL);
+	if (!data_buf)
+		return -ENOMEM;
+
+	if (len == 8)
+		test_buf = testdata_8bit;
+	else if (len == 4)
+		test_buf = testdata_4bit;
+	else {
+		pr_err("%s: Invalid bus_width %d\n",
+		       mmc_hostname(host), len);
+		kfree(data_buf);
+		return -EINVAL;
+	}
+
+	if (opcode == MMC_BUS_TEST_W)
+		memcpy(data_buf, test_buf, len);
+
+	mrq.cmd = &cmd;
+	mrq.data = &data;
+	cmd.opcode = opcode;
+	cmd.arg = 0;
+
+	/* NOTE HACK:  the MMC_RSP_SPI_R1 is always correct here, but we
+	 * rely on callers to never use this with "native" calls for reading
+	 * CSD or CID.  Native versions of those commands use the R2 type,
+	 * not R1 plus a data block.
+	 */
+	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;
+
+	data.blksz = len;
+	data.blocks = 1;
+	if (opcode == MMC_BUS_TEST_R)
+		data.flags = MMC_DATA_READ;
+	else
+		data.flags = MMC_DATA_WRITE;
+
+	data.sg = &sg;
+	data.sg_len = 1;
+	mmc_set_data_timeout(&data, card);
+	sg_init_one(&sg, data_buf, len);
+	mmc_wait_for_req(host, &mrq);
+	err = 0;
+	if (opcode == MMC_BUS_TEST_R) {
+		for (i = 0; i < len / 4; i++)
+			if ((test_buf[i] ^ data_buf[i]) != 0xff) {
+				err = -EIO;
+				break;
+			}
+	}
+	kfree(data_buf);
+
+	if (cmd.error)
+		return cmd.error;
+	if (data.error)
+		return data.error;
+
+	return err;
+}
+
+int mmc_bus_test(struct mmc_card *card, u8 bus_width)
+{
+	int width;
+
+	if (bus_width == MMC_BUS_WIDTH_8)
+		width = 8;
+	else if (bus_width == MMC_BUS_WIDTH_4)
+		width = 4;
+	else if (bus_width == MMC_BUS_WIDTH_1)
+		return 0; /* no need for test */
+	else
+		return -EINVAL;
+
+	/*
+	 * Ignore errors from BUS_TEST_W.  BUS_TEST_R will fail if there
+	 * is a problem.  This improves chances that the test will work.
+	 */
+	mmc_send_bus_test(card, card->host, MMC_BUS_TEST_W, width);
+	return mmc_send_bus_test(card, card->host, MMC_BUS_TEST_R, width);
+}
+
+static int mmc_send_hpi_cmd(struct mmc_card *card)
+{
+	unsigned int busy_timeout_ms = card->ext_csd.out_of_int_time;
+	struct mmc_host *host = card->host;
+	bool use_r1b_resp = true;
+	struct mmc_command cmd = {};
+	int err;
+
+	cmd.opcode = card->ext_csd.hpi_cmd;
+	cmd.arg = card->rca << 16 | 1;
+
+	/*
+	 * Make sure the host's max_busy_timeout fit the needed timeout for HPI.
+	 * In case it doesn't, let's instruct the host to avoid HW busy
+	 * detection, by using a R1 response instead of R1B.
+	 */
+	if (host->max_busy_timeout && busy_timeout_ms > host->max_busy_timeout)
+		use_r1b_resp = false;
+
+	if (cmd.opcode == MMC_STOP_TRANSMISSION && use_r1b_resp) {
+		cmd.flags = MMC_RSP_R1B | MMC_CMD_AC;
+		cmd.busy_timeout = busy_timeout_ms;
+	} else {
+		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+		use_r1b_resp = false;
+	}
+
+	err = mmc_wait_for_cmd(host, &cmd, 0);
+	if (err) {
+		pr_warn("%s: HPI error %d. Command response %#x\n",
+			mmc_hostname(host), err, cmd.resp[0]);
+		return err;
+	}
+
+	/* No need to poll when using HW busy detection. */
+	if (host->caps & MMC_CAP_WAIT_WHILE_BUSY && use_r1b_resp)
+		return 0;
+
+	/* Let's poll to find out when the HPI request completes. */
+	return mmc_poll_for_busy(card, busy_timeout_ms, MMC_BUSY_HPI);
+}
+
+/**
+ *	mmc_interrupt_hpi - Issue for High priority Interrupt
+ *	@card: the MMC card associated with the HPI transfer
+ *
+ *	Issued High Priority Interrupt, and check for card status
+ *	until out-of prg-state.
+ */
+int mmc_interrupt_hpi(struct mmc_card *card)
+{
+	int err;
+	u32 status;
+
+	if (!card->ext_csd.hpi_en) {
+		pr_info("%s: HPI enable bit unset\n", mmc_hostname(card->host));
+		return 1;
+	}
+
+	err = mmc_send_status(card, &status);
+	if (err) {
+		pr_err("%s: Get card status fail\n", mmc_hostname(card->host));
+		goto out;
+	}
+
+	switch (R1_CURRENT_STATE(status)) {
+	case R1_STATE_IDLE:
+	case R1_STATE_READY:
+	case R1_STATE_STBY:
+	case R1_STATE_TRAN:
+		/*
+		 * In idle and transfer states, HPI is not needed and the caller
+		 * can issue the next intended command immediately
+		 */
+		goto out;
+	case R1_STATE_PRG:
+		break;
+	default:
+		/* In all other states, it's illegal to issue HPI */
+		pr_debug("%s: HPI cannot be sent. Card state=%d\n",
+			mmc_hostname(card->host), R1_CURRENT_STATE(status));
+		err = -EINVAL;
+		goto out;
+	}
+
+	err = mmc_send_hpi_cmd(card);
+out:
+	return err;
+}
+
+int mmc_can_ext_csd(struct mmc_card *card)
+{
+	return (card && card->csd.mmca_vsn > CSD_SPEC_VER_3);
+}
+
+static int mmc_read_bkops_status(struct mmc_card *card)
+{
+	int err;
+	u8 *ext_csd;
+
+	err = mmc_get_ext_csd(card, &ext_csd);
+	if (err)
+		return err;
+
+	card->ext_csd.raw_bkops_status = ext_csd[EXT_CSD_BKOPS_STATUS];
+	card->ext_csd.raw_exception_status = ext_csd[EXT_CSD_EXP_EVENTS_STATUS];
+	kfree(ext_csd);
+	return 0;
+}
+
+/**
+ *	mmc_run_bkops - Run BKOPS for supported cards
+ *	@card: MMC card to run BKOPS for
+ *
+ *	Run background operations synchronously for cards having manual BKOPS
+ *	enabled and in case it reports urgent BKOPS level.
+*/
+void mmc_run_bkops(struct mmc_card *card)
+{
+	int err;
+
+	if (!card->ext_csd.man_bkops_en)
+		return;
+
+	err = mmc_read_bkops_status(card);
+	if (err) {
+		pr_err("%s: Failed to read bkops status: %d\n",
+		       mmc_hostname(card->host), err);
+		return;
+	}
+
+	if (!card->ext_csd.raw_bkops_status ||
+	    card->ext_csd.raw_bkops_status < EXT_CSD_BKOPS_LEVEL_2)
+		return;
+
+	mmc_retune_hold(card->host);
+
+	/*
+	 * For urgent BKOPS status, LEVEL_2 and higher, let's execute
+	 * synchronously. Future wise, we may consider to start BKOPS, for less
+	 * urgent levels by using an asynchronous background task, when idle.
+	 */
+	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+			 EXT_CSD_BKOPS_START, 1, MMC_BKOPS_TIMEOUT_MS);
+	if (err)
+		pr_warn("%s: Error %d starting bkops\n",
+			mmc_hostname(card->host), err);
+
+	mmc_retune_release(card->host);
+}
+EXPORT_SYMBOL(mmc_run_bkops);
+
+/*
+ * Flush the cache to the non-volatile storage.
+ */
+int mmc_flush_cache(struct mmc_card *card)
+{
+	int err = 0;
+
+	if (mmc_cache_enabled(card->host)) {
+		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+				 EXT_CSD_FLUSH_CACHE, 1,
+				 MMC_CACHE_FLUSH_TIMEOUT_MS);
+		if (err)
+			pr_err("%s: cache flush error %d\n",
+					mmc_hostname(card->host), err);
+	}
+
+	return err;
+}
+EXPORT_SYMBOL(mmc_flush_cache);
+
+static int mmc_cmdq_switch(struct mmc_card *card, bool enable)
+{
+	u8 val = enable ? EXT_CSD_CMDQ_MODE_ENABLED : 0;
+	int err;
+
+	if (!card->ext_csd.cmdq_support)
+		return -EOPNOTSUPP;
+
+	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_CMDQ_MODE_EN,
+			 val, card->ext_csd.generic_cmd6_time);
+	if (!err)
+		card->ext_csd.cmdq_en = enable;
+
+	return err;
+}
+
+int mmc_cmdq_enable(struct mmc_card *card)
+{
+	return mmc_cmdq_switch(card, true);
+}
+EXPORT_SYMBOL_GPL(mmc_cmdq_enable);
+
+int mmc_cmdq_disable(struct mmc_card *card)
+{
+	return mmc_cmdq_switch(card, false);
+}
+EXPORT_SYMBOL_GPL(mmc_cmdq_disable);
+
+int mmc_sanitize(struct mmc_card *card)
+{
+	struct mmc_host *host = card->host;
+	int err;
+
+	if (!mmc_can_sanitize(card)) {
+		pr_warn("%s: Sanitize not supported\n", mmc_hostname(host));
+		return -EOPNOTSUPP;
+	}
+
+	pr_debug("%s: Sanitize in progress...\n", mmc_hostname(host));
+
+	mmc_retune_hold(host);
+
+	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_SANITIZE_START,
+			 1, MMC_SANITIZE_TIMEOUT_MS);
+	if (err)
+		pr_err("%s: Sanitize failed err=%d\n", mmc_hostname(host), err);
+
+	/*
+	 * If the sanitize operation timed out, the card is probably still busy
+	 * in the R1_STATE_PRG. Rather than continue to wait, let's try to abort
+	 * it with a HPI command to get back into R1_STATE_TRAN.
+	 */
+	if (err == -ETIMEDOUT && !mmc_interrupt_hpi(card))
+		pr_warn("%s: Sanitize aborted\n", mmc_hostname(host));
+
+	mmc_retune_release(host);
+
+	pr_debug("%s: Sanitize completed\n", mmc_hostname(host));
+	return err;
+}
+EXPORT_SYMBOL_GPL(mmc_sanitize);
diff -urN linux-5.10.y-a/drivers/mmc/core/mmc_ops.h linux-5.10.y-b/drivers/mmc/core/mmc_ops.h
--- linux-5.10.y-a/drivers/mmc/core/mmc_ops.h	2023-06-30 15:39:09.475488080 +0800
+++ linux-5.10.y-b/drivers/mmc/core/mmc_ops.h	2023-01-03 16:40:46.000000000 +0800
@@ -48,5 +48,7 @@
 int mmc_cmdq_disable(struct mmc_card *card);
 int mmc_sanitize(struct mmc_card *card);
 
+int mmc_interrupt_hpi(struct mmc_card *card);
+
 #endif
 
diff -urN linux-5.10.y-a/drivers/mmc/core/sdio_bus.c linux-5.10.y-b/drivers/mmc/core/sdio_bus.c
--- linux-5.10.y-a/drivers/mmc/core/sdio_bus.c	2023-06-30 15:39:09.687479310 +0800
+++ linux-5.10.y-b/drivers/mmc/core/sdio_bus.c	2023-01-09 11:31:18.000000000 +0800
@@ -295,12 +295,6 @@
 	if (!(func->card->quirks & MMC_QUIRK_NONSTD_SDIO))
 		sdio_free_func_cis(func);
 
-	/*
-	 * We have now removed the link to the tuples in the
-	 * card structure, so remove the reference.
-	 */
-	put_device(&func->card->dev);
-
 	kfree(func->info);
 	kfree(func->tmpbuf);
 	kfree(func);
@@ -331,12 +325,6 @@
 
 	device_initialize(&func->dev);
 
-	/*
-	 * We may link to tuples in the card structure,
-	 * we need make sure we have a reference to it.
-	 */
-	get_device(&func->card->dev);
-
 	func->dev.parent = &card->dev;
 	func->dev.bus = &sdio_bus_type;
 	func->dev.release = sdio_release_func;
@@ -390,9 +378,10 @@
  */
 void sdio_remove_func(struct sdio_func *func)
 {
-	if (sdio_func_present(func))
-		device_del(&func->dev);
+	if (!sdio_func_present(func))
+		return;
 
+	device_del(&func->dev);
 	of_node_put(func->dev.of_node);
 	put_device(&func->dev);
 }
diff -urN linux-5.10.y-a/drivers/mmc/core/sdio.c linux-5.10.y-b/drivers/mmc/core/sdio.c
--- linux-5.10.y-a/drivers/mmc/core/sdio.c	2023-06-30 15:39:09.943468719 +0800
+++ linux-5.10.y-b/drivers/mmc/core/sdio.c	2023-01-30 11:00:56.000000000 +0800
@@ -1308,3 +1308,50 @@
 	return err;
 }
 
+
+
+int sdio_reset_comm(struct mmc_card *card)
+{
+	struct mmc_host *host = card->host;
+	u32 ocr;
+	u32 rocr;
+	int err;
+
+	pr_err("%s():\n", __func__);
+	mmc_claim_host(host);
+
+	mmc_retune_disable(host);
+
+	/* for realtek sdio wifi && mtk7668
+	 * need send IO reset command firstly
+	 */
+	if (card->cis.vendor == 588 || card->cis.vendor == 890)
+		sdio_reset(host);
+
+	mmc_go_idle(host);
+
+	mmc_set_clock(host, host->f_min);
+
+	err = mmc_send_io_op_cond(host, 0, &ocr);
+	if (err)
+		goto err;
+
+	rocr = mmc_select_voltage(host, ocr);
+	if (!rocr) {
+		err = -EINVAL;
+		goto err;
+	}
+
+	err = mmc_sdio_init_card(host, rocr, card);
+	if (err)
+		goto err;
+
+	mmc_release_host(host);
+	return 0;
+err:
+	pr_err("%s: Error resetting SDIO communications (%d)\n",
+	       mmc_hostname(host), err);
+	mmc_release_host(host);
+	return err;
+}
+EXPORT_SYMBOL(sdio_reset_comm);
diff -urN linux-5.10.y-a/drivers/mmc/core/sdio_cis.c linux-5.10.y-b/drivers/mmc/core/sdio_cis.c
--- linux-5.10.y-a/drivers/mmc/core/sdio_cis.c	2023-06-30 15:39:09.603482785 +0800
+++ linux-5.10.y-b/drivers/mmc/core/sdio_cis.c	2023-01-09 11:31:36.000000000 +0800
@@ -392,6 +392,12 @@
 		return ret;
 
 	/*
+	 * Since we've linked to tuples in the card structure,
+	 * we must make sure we have a reference to it.
+	 */
+	get_device(&func->card->dev);
+
+	/*
 	 * Vendor/device id is optional for function CIS, so
 	 * copy it from the card structure as needed.
 	 */
@@ -416,5 +422,11 @@
 	}
 
 	func->tuples = NULL;
+
+	/*
+	 * We have now removed the link to the tuples in the
+	 * card structure, so remove the reference.
+	 */
+	put_device(&func->card->dev);
 }
 
diff -urN linux-5.10.y-a/drivers/mmc/core/sdio_ops.c linux-5.10.y-b/drivers/mmc/core/sdio_ops.c
--- linux-5.10.y-a/drivers/mmc/core/sdio_ops.c	2023-06-30 15:39:10.007466072 +0800
+++ linux-5.10.y-b/drivers/mmc/core/sdio_ops.c	2023-01-09 11:32:56.000000000 +0800
@@ -81,18 +81,26 @@
 	cmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_AC;
 
 	err = mmc_wait_for_cmd(host, &cmd, 0);
-	if (err)
+	if (err){
+		printk("%s:mmc_wait_for_cmd err:%d\n",mmc_hostname(host),err);
 		return err;
+	}
 
 	if (mmc_host_is_spi(host)) {
 		/* host driver already reported errors */
 	} else {
-		if (cmd.resp[0] & R5_ERROR)
+		if (cmd.resp[0] & R5_ERROR){
+			printk("%s:mmc_wait_for_cmd resp:0x%x, EIO\n",mmc_hostname(host),cmd.resp[0]);
 			return -EIO;
-		if (cmd.resp[0] & R5_FUNCTION_NUMBER)
+		}
+		if (cmd.resp[0] & R5_FUNCTION_NUMBER){
+			printk("%s:mmc_wait_for_cmd resp:0x%x, EINVAL\n",mmc_hostname(host),cmd.resp[0]);
 			return -EINVAL;
-		if (cmd.resp[0] & R5_OUT_OF_RANGE)
+		}
+		if (cmd.resp[0] & R5_OUT_OF_RANGE){
+			printk("%s:mmc_wait_for_cmd resp:0x%x, ERANGE\n",mmc_hostname(host),cmd.resp[0]);
 			return -ERANGE;
+		}
 	}
 
 	if (out) {
diff -urN linux-5.10.y-a/drivers/mmc/host/meson-gx-mmc.c linux-5.10.y-b/drivers/mmc/host/meson-gx-mmc.c
--- linux-5.10.y-a/drivers/mmc/host/meson-gx-mmc.c	2023-06-30 15:43:14.699814777 +0800
+++ linux-5.10.y-b/drivers/mmc/host/meson-gx-mmc.c	2023-01-30 11:01:24.000000000 +0800
@@ -132,6 +132,8 @@
 
 #define MUX_CLK_NUM_PARENTS 2
 
+static struct mmc_host *sdio_host;
+
 struct meson_mmc_data {
 	unsigned int tx_delay_mask;
 	unsigned int rx_delay_mask;
@@ -972,8 +974,11 @@
 	if (status & (IRQ_END_OF_CHAIN | IRQ_RESP_STATUS)) {
 		if (data && !cmd->error)
 			data->bytes_xfered = data->blksz * data->blocks;
-
-		return IRQ_WAKE_THREAD;
+		if (meson_mmc_bounce_buf_read(data) ||
+		    meson_mmc_get_next_command(cmd))
+			ret = IRQ_WAKE_THREAD;
+		else
+			ret = IRQ_HANDLED;
 	}
 
 out:
@@ -985,6 +990,9 @@
 		writel(start, host->regs + SD_EMMC_START);
 	}
 
+	if (ret == IRQ_HANDLED)
+		meson_mmc_request_done(host->mmc, cmd->mrq);
+
 	return ret;
 }
 
@@ -1276,9 +1284,15 @@
 	}
 
 	mmc->ops = &meson_mmc_ops;
-	ret = mmc_add_host(mmc);
-	if (ret)
-		goto err_free_irq;
+	mmc_add_host(mmc);
+
+	/* if sdio_wifi */
+	printk("###%s: Check MMC Type ###\n",mmc_hostname(mmc));
+	if (!(mmc->caps2 & MMC_CAP2_NO_SDIO))
+	{
+		printk("###%s: Set sdio_host ###\n",mmc_hostname(mmc));
+		sdio_host = mmc;
+	}
 
 	return 0;
 
@@ -1352,13 +1366,49 @@
 	.remove		= meson_mmc_remove,
 	.driver		= {
 		.name = DRIVER_NAME,
-		.probe_type = PROBE_PREFER_ASYNCHRONOUS,
+		//.probe_type = PROBE_PREFER_ASYNCHRONOUS,
 		.of_match_table = of_match_ptr(meson_mmc_of_match),
 	},
 };
 
 module_platform_driver(meson_mmc_driver);
 
+
+static void sdio_rescan(struct mmc_host *mmc)
+{
+	int ret;
+
+	mmc->rescan_entered = 0;
+/*	mmc->host_rescan_disable = false;*/
+	mmc_detect_change(mmc, 0);
+	/* start the delayed_work */
+	ret = flush_work(&mmc->detect.work);
+	printk("[%s] flush_work ret:%d\n", __func__, ret);
+	/* wait for the delayed_work to finish */
+	if (!ret)
+		pr_info("Error: delayed_work mmc_rescan() already idle!\n");
+}
+
+void sdio_reinit(void)
+{
+#if 1
+	printk("[%s] \n", __func__);
+	if (sdio_host) {
+		if (sdio_host->card){
+			printk("[%s] sdio_reset_comm\n", __func__);
+			sdio_reset_comm(sdio_host->card);
+		}else{
+			printk("[%s] sdio_rescan\n", __func__);
+			sdio_rescan(sdio_host);
+		}
+	} else {
+		pr_info("Error: sdio_host is NULL\n");
+	}
+#endif
+	printk("[%s] finish\n", __func__);
+}
+EXPORT_SYMBOL(sdio_reinit);
+
 MODULE_DESCRIPTION("Amlogic S905*/GX*/AXG SD/eMMC driver");
 MODULE_AUTHOR("Kevin Hilman <khilman@baylibre.com>");
 MODULE_LICENSE("GPL v2");
diff -urN linux-5.10.y-a/drivers/mmc/host/renesas_sdhi_core.c linux-5.10.y-b/drivers/mmc/host/renesas_sdhi_core.c
--- linux-5.10.y-a/drivers/mmc/host/renesas_sdhi_core.c	2023-06-30 15:43:33.239404078 +0800
+++ linux-5.10.y-b/drivers/mmc/host/renesas_sdhi_core.c	2023-01-01 12:06:42.000000000 +0800
@@ -537,7 +537,7 @@
 			 SH_MOBILE_SDHI_SCC_TMPPORT2_HS400OSEL) &
 			sd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT2));
 
-	if (priv->quirks && (priv->quirks->hs400_calib_table || priv->quirks->hs400_bad_taps))
+	if (priv->adjust_hs400_calib_table)
 		renesas_sdhi_adjust_hs400_mode_disable(host);
 
 	sd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, CLK_CTL_SCLKEN |
diff -urN linux-5.10.y-a/drivers/pwm/core.c linux-5.10.y-b/drivers/pwm/core.c
--- linux-5.10.y-a/drivers/pwm/core.c	2023-06-30 15:37:31.988007479 +0800
+++ linux-5.10.y-b/drivers/pwm/core.c	2022-12-21 10:48:36.000000000 +0800
@@ -383,6 +383,25 @@
 }
 EXPORT_SYMBOL_GPL(pwmchip_remove);
 
+static void devm_pwmchip_remove(void *data)
+{
+	struct pwm_chip *chip = data;
+
+	pwmchip_remove(chip);
+}
+
+int devm_pwmchip_add(struct device *dev, struct pwm_chip *chip)
+{
+	int ret;
+
+	ret = pwmchip_add(chip);
+	if (ret)
+		return ret;
+
+	return devm_add_action_or_reset(dev, devm_pwmchip_remove, chip);
+}
+EXPORT_SYMBOL_GPL(devm_pwmchip_add);
+
 /**
  * pwm_request() - request a PWM device
  * @pwm: global PWM device index
diff -urN linux-5.10.y-a/drivers/pwm/pwm-meson.c linux-5.10.y-b/drivers/pwm/pwm-meson.c
--- linux-5.10.y-a/drivers/pwm/pwm-meson.c	2023-06-30 15:37:51.451023523 +0800
+++ linux-5.10.y-b/drivers/pwm/pwm-meson.c	2022-12-21 15:41:32.000000000 +0800
@@ -43,8 +43,12 @@
 #include <linux/slab.h>
 #include <linux/spinlock.h>
 
+#ifdef CONFIG_AMLOGIC_MODIFY
+#include <linux/amlogic/pwm-meson.h>
+#else
 #define REG_PWM_A		0x0
 #define REG_PWM_B		0x4
+
 #define PWM_LOW_MASK		GENMASK(15, 0)
 #define PWM_HIGH_MASK		GENMASK(31, 16)
 
@@ -62,29 +66,6 @@
 
 #define MESON_NUM_PWMS		2
 
-static struct meson_pwm_channel_data {
-	u8		reg_offset;
-	u8		clk_sel_shift;
-	u8		clk_div_shift;
-	u32		clk_en_mask;
-	u32		pwm_en_mask;
-} meson_pwm_per_channel_data[MESON_NUM_PWMS] = {
-	{
-		.reg_offset	= REG_PWM_A,
-		.clk_sel_shift	= MISC_A_CLK_SEL_SHIFT,
-		.clk_div_shift	= MISC_A_CLK_DIV_SHIFT,
-		.clk_en_mask	= MISC_A_CLK_EN,
-		.pwm_en_mask	= MISC_A_EN,
-	},
-	{
-		.reg_offset	= REG_PWM_B,
-		.clk_sel_shift	= MISC_B_CLK_SEL_SHIFT,
-		.clk_div_shift	= MISC_B_CLK_DIV_SHIFT,
-		.clk_en_mask	= MISC_B_CLK_EN,
-		.pwm_en_mask	= MISC_B_EN,
-	}
-};
-
 struct meson_pwm_channel {
 	unsigned int hi;
 	unsigned int lo;
@@ -111,11 +92,60 @@
 	 */
 	spinlock_t lock;
 };
+#endif
 
+static struct meson_pwm_channel_data {
+	u8		reg_offset;
+	u8		clk_sel_shift;
+	u8		clk_div_shift;
+	u32		clk_en_mask;
+	u32		pwm_en_mask;
+#ifdef CONFIG_AMLOGIC_MODIFY
+} meson_pwm_per_channel_data[] = {
+#else
+} meson_pwm_per_channel_data[MESON_NUM_PWMS] = {
+#endif
+	{
+		.reg_offset	= REG_PWM_A,
+		.clk_sel_shift	= MISC_A_CLK_SEL_SHIFT,
+		.clk_div_shift	= MISC_A_CLK_DIV_SHIFT,
+		.clk_en_mask	= MISC_A_CLK_EN,
+		.pwm_en_mask	= MISC_A_EN,
+	},
+	{
+		.reg_offset	= REG_PWM_B,
+		.clk_sel_shift	= MISC_B_CLK_SEL_SHIFT,
+		.clk_div_shift	= MISC_B_CLK_DIV_SHIFT,
+		.clk_en_mask	= MISC_B_CLK_EN,
+		.pwm_en_mask	= MISC_B_EN,
+	},
+#ifdef CONFIG_AMLOGIC_MODIFY
+	{
+		.reg_offset	= REG_PWM_A2,
+		.clk_sel_shift	= MISC_A_CLK_SEL_SHIFT,
+		.clk_div_shift	= MISC_A_CLK_DIV_SHIFT,
+		.clk_en_mask	= MISC_A_CLK_EN,
+		.pwm_en_mask	= MISC_A2_EN,
+	},
+	{
+		.reg_offset	= REG_PWM_B2,
+		.clk_sel_shift	= MISC_B_CLK_SEL_SHIFT,
+		.clk_div_shift	= MISC_B_CLK_DIV_SHIFT,
+		.clk_en_mask	= MISC_B_CLK_EN,
+		.pwm_en_mask	= MISC_B2_EN,
+	},
+#endif
+};
+
+#ifdef CONFIG_AMLOGIC_MODIFY
+struct meson_pwm *to_meson_pwm(struct pwm_chip *chip)
+#else
 static inline struct meson_pwm *to_meson_pwm(struct pwm_chip *chip)
+#endif
 {
 	return container_of(chip, struct meson_pwm, chip);
 }
+EXPORT_SYMBOL(to_meson_pwm);
 
 static int meson_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)
 {
@@ -129,16 +159,28 @@
 		return 0;
 
 	channel = &meson->channels[pwm->hwpwm];
+#ifdef CONFIG_AMLOGIC_MODIFY
+	if (!meson->data->extern_clk)
+#endif
+		if (channel->clk_parent) {
+			err = clk_set_parent(channel->clk, channel->clk_parent);
+			if (err < 0) {
+				dev_err(dev, "failed to set parent %s for %s: %d\n",
+					__clk_get_name(channel->clk_parent),
+					__clk_get_name(channel->clk), err);
+					return err;
+			}
+		}
 
-	if (channel->clk_parent) {
-		err = clk_set_parent(channel->clk, channel->clk_parent);
-		if (err < 0) {
-			dev_err(dev, "failed to set parent %s for %s: %d\n",
-				__clk_get_name(channel->clk_parent),
-				__clk_get_name(channel->clk), err);
+#ifdef CONFIG_AMLOGIC_MODIFY
+	if (meson->data->extern_clk) {
+		err = clk_set_rate(channel->clk, DEFAULT_EXTERN_CLK);
+		if (err) {
+			pr_err("%s: error in setting pwm rate!\n", __func__);
 			return err;
 		}
 	}
+#endif
 
 	err = clk_prepare_enable(channel->clk);
 	if (err < 0) {
@@ -147,6 +189,10 @@
 		return err;
 	}
 
+#ifdef CONFIG_AMLOGIC_MODIFY
+	channel->clk_rate = clk_get_rate(channel->clk);
+#endif
+
 	return pwm_set_chip_data(pwm, channel);
 }
 
@@ -163,21 +209,21 @@
 {
 	struct meson_pwm_channel *channel = pwm_get_chip_data(pwm);
 	unsigned int duty, period, pre_div, cnt, duty_cnt;
-	unsigned long fin_freq;
+	unsigned long fin_freq = -1;
 
 	duty = state->duty_cycle;
 	period = state->period;
 
-	/*
-	 * Note this is wrong. The result is an output wave that isn't really
-	 * inverted and so is wrongly identified by .get_state as normal.
-	 * Fixing this needs some care however as some machines might rely on
-	 * this.
-	 */
 	if (state->polarity == PWM_POLARITY_INVERSED)
 		duty = period - duty;
 
+#ifdef CONFIG_AMLOGIC_MODIFY
+	/*get_clk_rate()not use in Interrupt context*/
+	fin_freq = channel->clk_rate;
+#else
 	fin_freq = clk_get_rate(channel->clk);
+#endif
+
 	if (fin_freq == 0) {
 		dev_err(meson->chip.dev, "invalid source clock frequency\n");
 		return -EINVAL;
@@ -221,10 +267,30 @@
 			duty, pre_div, duty_cnt);
 
 		channel->pre_div = pre_div;
+#ifndef CONFIG_AMLOGIC_MODIFY
 		channel->hi = duty_cnt;
 		channel->lo = cnt - duty_cnt;
+#else
+		if (duty_cnt == 0)
+			duty_cnt++;
+
+		channel->hi = duty_cnt - 1;
+		channel->lo = cnt - duty_cnt - 1;
+#endif
 	}
 
+#ifdef CONFIG_AMLOGIC_MODIFY
+	/*
+	 * duty_cycle equal 0% and 100%,constant should be enabled,
+	 * high and low count will not incease one;
+	 * otherwise, high and low count increase one.
+	 */
+	if (duty == period || duty == 0)
+		pwm_constant_enable(meson, pwm->hwpwm);
+	else
+		pwm_constant_disable(meson, pwm->hwpwm);
+#endif
+
 	return 0;
 }
 
@@ -234,6 +300,10 @@
 	struct meson_pwm_channel_data *channel_data;
 	unsigned long flags;
 	u32 value;
+#ifdef CONFIG_AMLOGIC_MODIFY
+	unsigned long set_clk;
+	u32 err;
+#endif
 
 	channel_data = &meson_pwm_per_channel_data[pwm->hwpwm];
 
@@ -254,6 +324,23 @@
 	writel(value, meson->base + REG_MISC_AB);
 
 	spin_unlock_irqrestore(&meson->lock, flags);
+#ifdef CONFIG_AMLOGIC_MODIFY
+	if (meson->data->extern_clk) {
+		/*get_clk_rate()not use in Interrupt context*/
+		if (channel->clk_div == channel->pre_div)
+			return;
+
+		set_clk = channel->clk_rate;
+		if (set_clk == 0)
+			dev_err(meson->chip.dev, "invalid source clock frequency\n");
+
+		set_clk /= (channel->pre_div + 1);
+		err = clk_set_rate(channel->clk, set_clk);
+		if (err)
+			pr_err("%s: error in setting pwm rate!\n", __func__);
+		channel->clk_div = channel->pre_div;
+	}
+#endif
 }
 
 static void meson_pwm_disable(struct meson_pwm *meson, struct pwm_device *pwm)
@@ -333,6 +420,40 @@
 	return cnt * fin_ns * (channel->pre_div + 1);
 }
 
+#ifdef CONFIG_AMLOGIC_MODIFY
+static void meson_v2_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,
+				   struct pwm_state *state)
+{
+	struct meson_pwm *meson = to_meson_pwm(chip);
+	u32 value, mask;
+
+	if (!state)
+		return;
+
+	switch (pwm->hwpwm) {
+	case 0:
+		mask = MISC_A_EN;
+		break;
+
+	case 1:
+		mask = MISC_B_EN;
+		break;
+
+	case 2:
+		mask = MISC_A2_EN;
+		break;
+
+	case 3:
+		mask = MISC_B2_EN;
+
+	default:
+		return;
+	}
+	value = readl(meson->base + REG_MISC_AB);
+	state->enabled = (value & mask) != 0;
+}
+#endif
+
 static void meson_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,
 				struct pwm_state *state)
 {
@@ -344,6 +465,12 @@
 	if (!state)
 		return;
 
+#ifdef CONFIG_AMLOGIC_MODIFY
+/* TODO: later, clk tree will be used to synchronize the status of pwm */
+	if (meson->data->extern_clk)
+		return meson_v2_pwm_get_state(chip, pwm, state);
+#endif
+
 	channel = &meson->channels[pwm->hwpwm];
 	channel_data = &meson_pwm_per_channel_data[pwm->hwpwm];
 
@@ -372,7 +499,6 @@
 		state->period = 0;
 		state->duty_cycle = 0;
 	}
-	state->polarity = PWM_POLARITY_NORMAL;
 }
 
 static const struct pwm_ops meson_pwm_ops = {
@@ -383,83 +509,127 @@
 	.owner = THIS_MODULE,
 };
 
-static const char * const pwm_meson8b_parent_names[] = {
+#ifndef CONFIG_AMLOGIC_REMOVE_OLD
+static char *pwm_meson8b_parent_names[] __initdata = {
 	"xtal", "vid_pll", "fclk_div4", "fclk_div3"
 };
 
-static const struct meson_pwm_data pwm_meson8b_data = {
+static struct meson_pwm_data pwm_meson8b_data __refdata = {
 	.parent_names = pwm_meson8b_parent_names,
 	.num_parents = ARRAY_SIZE(pwm_meson8b_parent_names),
+#ifdef CONFIG_AMLOGIC_MODIFY
+	.double_channel = false,
+#endif
 };
 
-static const char * const pwm_gxbb_parent_names[] = {
+static char *pwm_gxbb_parent_names[] __initdata = {
 	"xtal", "hdmi_pll", "fclk_div4", "fclk_div3"
 };
 
-static const struct meson_pwm_data pwm_gxbb_data = {
+static struct meson_pwm_data pwm_gxbb_data __refdata = {
 	.parent_names = pwm_gxbb_parent_names,
 	.num_parents = ARRAY_SIZE(pwm_gxbb_parent_names),
+#ifdef CONFIG_AMLOGIC_MODIFY
+	.double_channel = false,
+#endif
 };
 
 /*
  * Only the 2 first inputs of the GXBB AO PWMs are valid
  * The last 2 are grounded
  */
-static const char * const pwm_gxbb_ao_parent_names[] = {
+static char *pwm_gxbb_ao_parent_names[] __initdata = {
 	"xtal", "clk81"
 };
 
-static const struct meson_pwm_data pwm_gxbb_ao_data = {
+static struct meson_pwm_data pwm_gxbb_ao_data __refdata = {
 	.parent_names = pwm_gxbb_ao_parent_names,
 	.num_parents = ARRAY_SIZE(pwm_gxbb_ao_parent_names),
+#ifdef CONFIG_AMLOGIC_MODIFY
+	.double_channel = false,
+#endif
 };
 
-static const char * const pwm_axg_ee_parent_names[] = {
+static char *pwm_axg_ee_parent_names[] __initdata = {
 	"xtal", "fclk_div5", "fclk_div4", "fclk_div3"
 };
 
-static const struct meson_pwm_data pwm_axg_ee_data = {
+static struct meson_pwm_data pwm_axg_ee_data __refdata = {
 	.parent_names = pwm_axg_ee_parent_names,
 	.num_parents = ARRAY_SIZE(pwm_axg_ee_parent_names),
+#ifdef CONFIG_AMLOGIC_MODIFY
+	.double_channel = true,
+#endif
 };
 
-static const char * const pwm_axg_ao_parent_names[] = {
-	"xtal", "axg_ao_clk81", "fclk_div4", "fclk_div5"
+static char *pwm_axg_ao_parent_names[] __initdata = {
+	"xtal", "aoclk81", "fclk_div4", "fclk_div5"
 };
 
-static const struct meson_pwm_data pwm_axg_ao_data = {
+static struct meson_pwm_data pwm_axg_ao_data __refdata = {
 	.parent_names = pwm_axg_ao_parent_names,
 	.num_parents = ARRAY_SIZE(pwm_axg_ao_parent_names),
+#ifdef CONFIG_AMLOGIC_MODIFY
+	.double_channel = true,
+#endif
 };
+#endif
 
-static const char * const pwm_g12a_ao_ab_parent_names[] = {
-	"xtal", "g12a_ao_clk81", "fclk_div4", "fclk_div5"
+static char *pwm_g12a_ao_ab_parent_names[] __initdata = {
+	"xtal", "aoclk81", "fclk_div4", "fclk_div5"
 };
 
-static const struct meson_pwm_data pwm_g12a_ao_ab_data = {
+static struct meson_pwm_data pwm_g12a_ao_ab_data __refdata = {
 	.parent_names = pwm_g12a_ao_ab_parent_names,
 	.num_parents = ARRAY_SIZE(pwm_g12a_ao_ab_parent_names),
+#ifdef CONFIG_AMLOGIC_MODIFY
+	.double_channel = true,
+#endif
 };
 
-static const char * const pwm_g12a_ao_cd_parent_names[] = {
-	"xtal", "g12a_ao_clk81",
+static char *pwm_g12a_ao_cd_parent_names[] __initdata = {
+	"xtal", "aoclk81",
 };
 
-static const struct meson_pwm_data pwm_g12a_ao_cd_data = {
+static struct meson_pwm_data pwm_g12a_ao_cd_data __refdata = {
 	.parent_names = pwm_g12a_ao_cd_parent_names,
 	.num_parents = ARRAY_SIZE(pwm_g12a_ao_cd_parent_names),
+#ifdef CONFIG_AMLOGIC_MODIFY
+	.double_channel = true,
+#endif
 };
 
-static const char * const pwm_g12a_ee_parent_names[] = {
+static char *pwm_g12a_ee_parent_names[] __initdata = {
 	"xtal", "hdmi_pll", "fclk_div4", "fclk_div3"
 };
 
-static const struct meson_pwm_data pwm_g12a_ee_data = {
+static struct meson_pwm_data pwm_g12a_ee_data __refdata = {
 	.parent_names = pwm_g12a_ee_parent_names,
 	.num_parents = ARRAY_SIZE(pwm_g12a_ee_parent_names),
+#ifdef CONFIG_AMLOGIC_MODIFY
+	.double_channel = true,
+#endif
 };
 
+#ifdef CONFIG_AMLOGIC_MODIFY
+static  char *pwm_t5d_parent_names[] __initdata = {
+	"xtal", "clk81", "fclk_div4", "fclk_div5"
+};
+
+static struct meson_pwm_data pwm_t5d_data __refdata = {
+	.parent_names = pwm_t5d_parent_names,
+	.num_parents = ARRAY_SIZE(pwm_t5d_parent_names),
+	.double_channel = true,
+};
+
+static struct meson_pwm_data pwm_v2_data __initdata = {
+	.double_channel = true,
+	.extern_clk = true,
+};
+#endif
+
 static const struct of_device_id meson_pwm_matches[] = {
+#ifndef CONFIG_AMLOGIC_REMOVE_OLD
 	{
 		.compatible = "amlogic,meson8b-pwm",
 		.data = &pwm_meson8b_data
@@ -480,6 +650,7 @@
 		.compatible = "amlogic,meson-axg-ao-pwm",
 		.data = &pwm_axg_ao_data
 	},
+#endif
 	{
 		.compatible = "amlogic,meson-g12a-ee-pwm",
 		.data = &pwm_g12a_ee_data
@@ -492,6 +663,28 @@
 		.compatible = "amlogic,meson-g12a-ao-pwm-cd",
 		.data = &pwm_g12a_ao_cd_data
 	},
+#ifdef CONFIG_AMLOGIC_MODIFY
+	{
+		.compatible = "amlogic,meson-tm2-ee-pwm",
+		.data = &pwm_g12a_ee_data
+	},
+	{
+		.compatible = "amlogic,meson-tm2-ao-pwm-ab",
+		.data = &pwm_g12a_ao_ab_data
+	},
+	{
+		.compatible = "amlogic,meson-tm2-ao-pwm-cd",
+		.data = &pwm_g12a_ao_cd_data
+	},
+	{
+		.compatible = "amlogic,meson-t5d-ee-pwm",
+		.data = &pwm_t5d_data
+	},
+	{
+		.compatible = "amlogic,meson-v2-pwm",
+		.data = &pwm_v2_data
+	},
+#endif
 	{},
 };
 MODULE_DEVICE_TABLE(of, meson_pwm_matches);
@@ -512,7 +705,7 @@
 		init.name = name;
 		init.ops = &clk_mux_ops;
 		init.flags = 0;
-		init.parent_names = meson->data->parent_names;
+		init.parent_names = (const char *const *)meson->data->parent_names;
 		init.num_parents = meson->data->num_parents;
 
 		channel->mux.reg = meson->base + REG_MISC_AB;
@@ -541,32 +734,95 @@
 	return 0;
 }
 
+#ifdef CONFIG_AMLOGIC_MODIFY
+static int meson_pwm_v2_init_channels(struct meson_pwm *meson)
+{
+	struct meson_pwm_channel *channels = meson->channels;
+	struct device *dev = meson->chip.dev;
+	unsigned int i;
+	char name[255];
+
+	for (i = 0; i < (meson->chip.npwm / 2); i++) {
+		snprintf(name, sizeof(name), "clkin%u", i);
+		(channels + i)->clk = devm_clk_get(dev, name);
+		if (IS_ERR((channels + i)->clk)) {
+			dev_err(meson->chip.dev, "can't get device clock\n");
+			return PTR_ERR((channels + i)->clk);
+		}
+		(channels + i + 2)->clk = (channels + i)->clk;
+	}
+
+	return 0;
+}
+
+static struct regmap_config meson_pwm_regmap_config = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = 4,
+};
+#endif
+
 static int meson_pwm_probe(struct platform_device *pdev)
 {
 	struct meson_pwm *meson;
+	struct meson_pwm_data *match;
 	struct resource *regs;
 	int err;
+	int i;
 
 	meson = devm_kzalloc(&pdev->dev, sizeof(*meson), GFP_KERNEL);
 	if (!meson)
 		return -ENOMEM;
+	meson->data = devm_kzalloc(&pdev->dev, sizeof(*meson->data), GFP_KERNEL);
+	if (!meson->data)
+		return -ENOMEM;
 
 	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	meson->base = devm_ioremap_resource(&pdev->dev, regs);
 	if (IS_ERR(meson->base))
 		return PTR_ERR(meson->base);
 
+#ifdef CONFIG_AMLOGIC_MODIFY
+	meson_pwm_regmap_config.max_register = resource_size(regs) - 4;
+	meson_pwm_regmap_config.name = devm_kasprintf(&pdev->dev,
+						      GFP_KERNEL, "%s", "pwm");
+	meson->regmap_base = devm_regmap_init_mmio(&pdev->dev,
+						   meson->base,
+						   &meson_pwm_regmap_config);
+#endif
 	spin_lock_init(&meson->lock);
 	meson->chip.dev = &pdev->dev;
 	meson->chip.ops = &meson_pwm_ops;
 	meson->chip.base = -1;
+	match = (struct meson_pwm_data *)of_device_get_match_data(&pdev->dev);
+	meson->data->num_parents = match->num_parents;
+	meson->data->double_channel = match->double_channel;
+	meson->data->extern_clk = match->extern_clk;
+	meson->data->parent_names = devm_kzalloc(&pdev->dev, sizeof(char *) * (match->num_parents),
+			GFP_KERNEL);
+	if (!meson->data)
+		return -ENOMEM;
+
+	for (i = 0; i < match->num_parents; i++)
+		meson->data->parent_names[i] = devm_kstrdup(&pdev->dev, match->parent_names[i],
+				GFP_KERNEL);
+
+#ifndef CONFIG_AMLOGIC_MODIFY
 	meson->chip.npwm = MESON_NUM_PWMS;
+#else
+	if (meson->data->double_channel)
+		meson->chip.npwm = MESON_DOUBLE_NUM_PWMS;
+	else
+		meson->chip.npwm = MESON_NUM_PWMS;
+#endif
 	meson->chip.of_xlate = of_pwm_xlate_with_flags;
 	meson->chip.of_pwm_n_cells = 3;
-
-	meson->data = of_device_get_match_data(&pdev->dev);
-
-	err = meson_pwm_init_channels(meson);
+#ifdef CONFIG_AMLOGIC_MODIFY
+	if (meson->data->extern_clk)
+		err = meson_pwm_v2_init_channels(meson);
+	else
+#endif
+		err = meson_pwm_init_channels(meson);
 	if (err < 0)
 		return err;
 
@@ -577,6 +833,11 @@
 	}
 
 	platform_set_drvdata(pdev, meson);
+#ifdef CONFIG_AMLOGIC_MODIFY
+	/*for constant,blinks functions*/
+	if (meson->data->double_channel)
+		meson_pwm_sysfs_init(&pdev->dev);
+#endif
 
 	return 0;
 }
@@ -584,7 +845,10 @@
 static int meson_pwm_remove(struct platform_device *pdev)
 {
 	struct meson_pwm *meson = platform_get_drvdata(pdev);
-
+#ifdef CONFIG_AMLOGIC_MODIFY
+	if (meson->data->double_channel)
+		meson_pwm_sysfs_exit(&pdev->dev);
+#endif
 	return pwmchip_remove(&meson->chip);
 }
 
@@ -596,7 +860,29 @@
 	.probe = meson_pwm_probe,
 	.remove = meson_pwm_remove,
 };
+
+#ifdef CONFIG_AMLOGIC_MODIFY
+static int __init meson_pwm_init(void)
+{
+	const struct of_device_id *match_id;
+	int ret;
+
+	match_id = meson_pwm_matches;
+	meson_pwm_driver.driver.of_match_table = match_id;
+	ret = platform_driver_register(&meson_pwm_driver);
+	return ret;
+}
+
+static void __exit meson_pwm_exit(void)
+{
+	platform_driver_unregister(&meson_pwm_driver);
+}
+
+fs_initcall_sync(meson_pwm_init);
+#else
 module_platform_driver(meson_pwm_driver);
+#endif
+module_exit(meson_pwm_exit);
 
 MODULE_DESCRIPTION("Amlogic Meson PWM Generator driver");
 MODULE_AUTHOR("Neil Armstrong <narmstrong@baylibre.com>");
Binary files linux-5.10.y-a/._.DS_Store and linux-5.10.y-b/._.DS_Store differ
Binary files linux-5.10.y-a/.DS_Store and linux-5.10.y-b/.DS_Store differ
diff -urN linux-5.10.y-a/fs/read_write.c linux-5.10.y-b/fs/read_write.c
--- linux-5.10.y-a/fs/read_write.c	2023-01-19 12:53:24.000000000 +0800
+++ linux-5.10.y-b/fs/read_write.c	2023-01-19 12:53:12.000000000 +0800
@@ -503,6 +503,7 @@
 	inc_syscr(current);
 	return ret;
 }
+EXPORT_SYMBOL(vfs_read);
 
 static ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)
 {
@@ -613,6 +614,7 @@
 	file_end_write(file);
 	return ret;
 }
+EXPORT_SYMBOL(vfs_write);
 
 /* file_ppos returns &file->f_pos or NULL if file is stream */
 static inline loff_t *file_ppos(struct file *file)
diff -urN linux-5.10.y-a/fs/stat.c linux-5.10.y-b/fs/stat.c
--- linux-5.10.y-a/fs/stat.c	2023-01-17 16:48:34.000000000 +0800
+++ linux-5.10.y-b/fs/stat.c	2023-01-19 12:40:48.000000000 +0800
@@ -215,6 +215,7 @@
 	return vfs_statx(dfd, filename, flags | AT_NO_AUTOMOUNT,
 			 stat, STATX_BASIC_STATS);
 }
+EXPORT_SYMBOL(vfs_fstatat);
 
 #ifdef __ARCH_WANT_OLD_STAT
 
Binary files linux-5.10.y-a/include/._.DS_Store and linux-5.10.y-b/include/._.DS_Store differ
Binary files linux-5.10.y-a/include/.DS_Store and linux-5.10.y-b/include/.DS_Store differ
Binary files linux-5.10.y-a/include/dt-bindings/._.DS_Store and linux-5.10.y-b/include/dt-bindings/._.DS_Store differ
Binary files linux-5.10.y-a/include/dt-bindings/.DS_Store and linux-5.10.y-b/include/dt-bindings/.DS_Store differ
Binary files linux-5.10.y-a/include/dt-bindings/pwm/._meson.h and linux-5.10.y-b/include/dt-bindings/pwm/._meson.h differ
diff -urN linux-5.10.y-a/include/dt-bindings/pwm/meson.h linux-5.10.y-b/include/dt-bindings/pwm/meson.h
--- linux-5.10.y-a/include/dt-bindings/pwm/meson.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/include/dt-bindings/pwm/meson.h	2022-11-27 09:30:02.000000000 +0800
@@ -0,0 +1,30 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef _DT_BINDINGS_PWM_MESON_H
+#define _DT_BINDINGS_PWM_MESON_H
+
+/*defination for meson pwm channel index
+ *	for example:
+ *	1.there are four pwm controllers for axg:
+ *	pwm A/B ,pwm C/D, pwm AOA/AOB, pwm AOC/AOD.
+ *	each controller has four pwm channels:
+ *	MESON_PWM_0,MESON_PWM_1,MESON_PWM_2,MESON_PWM_3
+ *	when double pwm channels used, pwm channel
+ *	[ MESON_PWM_0 and MESON_PWM_2 ],
+ *	[ MESON_PWM_1 and MESON_PWM_3 ],
+ *	should be used together.
+ *
+ *	2.there are two three pwm controllers for m8b:
+ *	pwm A/B,pwm C/D,pwm E/F.
+ *	each controllere has two pwm channels:
+ *	MESON_PWM_0 and MESON_PWM_1.
+ */
+#define		MESON_PWM_0  0
+#define		MESON_PWM_1  1
+#define		MESON_PWM_2  2
+#define		MESON_PWM_3  3
+
+#endif
diff -urN linux-5.10.y-a/include/linux/amlogic/aml_gpio_consumer.h linux-5.10.y-b/include/linux/amlogic/aml_gpio_consumer.h
--- linux-5.10.y-a/include/linux/amlogic/aml_gpio_consumer.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/include/linux/amlogic/aml_gpio_consumer.h	2022-11-27 09:30:04.000000000 +0800
@@ -0,0 +1,43 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#include <linux/gpio.h>
+#ifndef __AML_GPIO_CONSUMER_H__
+#define __AML_GPIO_CONSUMER_H__
+#include <linux/gpio/consumer.h>
+#include <linux/of_gpio.h>
+#define AML_GPIO_IRQ(irq_bank, filter, type) \
+(((irq_bank) & 0x7 | (filter) & 0x7) << 8 | (type & 0x3) << 16)
+
+enum {
+	GPIO_IRQ0 = 0,
+	GPIO_IRQ1,
+	GPIO_IRQ2,
+	GPIO_IRQ3,
+	GPIO_IRQ4,
+	GPIO_IRQ5,
+	GPIO_IRQ6,
+	GPIO_IRQ7,
+};
+
+enum {
+	GPIO_IRQ_HIGH = 0,
+	GPIO_IRQ_LOW,
+	GPIO_IRQ_RISING,
+	GPIO_IRQ_FALLING,
+};
+
+enum {
+	FILTER_NUM0 = 0,
+	FILTER_NUM1,
+	FILTER_NUM2,
+	FILTER_NUM3,
+	FILTER_NUM4,
+	FILTER_NUM5,
+	FILTER_NUM6,
+	FILTER_NUM7,
+};
+
+#endif
Binary files linux-5.10.y-a/include/linux/amlogic/._aml_sd.h and linux-5.10.y-b/include/linux/amlogic/._aml_sd.h differ
diff -urN linux-5.10.y-a/include/linux/amlogic/aml_sd.h linux-5.10.y-b/include/linux/amlogic/aml_sd.h
--- linux-5.10.y-a/include/linux/amlogic/aml_sd.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/include/linux/amlogic/aml_sd.h	2022-12-26 15:43:54.000000000 +0800
@@ -0,0 +1,439 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * include/linux/amlogic/aml_sd.h
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __AML_SD_H__
+#define __AML_SD_H__
+
+#include <linux/mmc/card.h>
+#include <linux/interrupt.h>
+/* unknown */
+#define CARD_TYPE_UNKNOWN		0
+/* MMC card */
+#define CARD_TYPE_MMC			1
+/* SD card */
+#define CARD_TYPE_SD			2
+/* SDIO card */
+#define CARD_TYPE_SDIO			3
+/* SD combo (IO+mem) card */
+#define CARD_TYPE_SD_COMBO		4
+/* NON sdio device (means SD/MMC card) */
+#define CARD_TYPE_NON_SDIO		5
+
+#define aml_card_type_unknown(c)	((c)->card_type == CARD_TYPE_UNKNOWN)
+#define aml_card_type_mmc(c)		((c)->card_type == CARD_TYPE_MMC)
+#define aml_card_type_sd(c)		((c)->card_type == CARD_TYPE_SD)
+#define aml_card_type_sdio(c)		((c)->card_type == CARD_TYPE_SDIO)
+#define aml_card_type_non_sdio(c)	((c)->card_type == CARD_TYPE_NON_SDIO)
+
+/* flag is "AML" */
+#define TUNED_FLAG            0x004C4D41
+/* version is "V2" */
+#define TUNED_VERSION         0x00003256
+/* magic is 0x00487e44 */
+#define TUNED_MAGIC           0x00487e44
+
+struct mmc_phase {
+	unsigned int core_phase;
+	unsigned int tx_phase;
+	unsigned int rx_phase;
+	unsigned int tx_delay;
+};
+
+struct para_e {
+	struct mmc_phase init;
+	struct mmc_phase hs;
+	struct mmc_phase hs2;
+	struct mmc_phase hs4;
+};
+
+#define LATCHING_RXPHASE 0
+#define LATCHING_TXPHASE 1
+#define LATCHING_FIXADJ 2
+
+struct meson_mmc_data {
+	unsigned int tx_delay_mask;
+	unsigned int rx_delay_mask;
+	unsigned int always_on;
+	unsigned int adjust;
+	unsigned int clk_core_phase;
+	u8 latching_mode;
+};
+
+enum aml_host_bus_fsm { /* Host bus fsm status */
+	BUS_FSM_IDLE,           /* 0, idle */
+	BUS_FSM_SND_CMD,        /* 1, send cmd */
+	BUS_FSM_CMD_DONE,       /* 2, wait for cmd done */
+	BUS_FSM_RESP_START,     /* 3, resp start */
+	BUS_FSM_RESP_DONE,      /* 4, wait for resp done */
+	BUS_FSM_DATA_START,     /* 5, data start */
+	BUS_FSM_DATA_DONE,      /* 6, wait for data done */
+	BUS_FSM_DESC_WRITE_BACK,/* 7, wait for desc write back */
+	BUS_FSM_IRQ_SERVICE,    /* 8, wait for irq service */
+};
+
+struct sd_emmc_desc {
+	u32 cmd_cfg;
+	u32 cmd_arg;
+	u32 cmd_data;
+	u32 cmd_resp;
+};
+
+struct meson_mmc_hole {
+	u8 start;
+	u8 size;
+};
+
+struct hs400_para {
+	unsigned int delay1;
+	unsigned int delay2;
+	unsigned int intf3;
+	unsigned int flag;
+};
+
+struct hs200_para {
+	unsigned int adjust;
+};
+
+struct hs_para {
+	unsigned int adjust;
+};
+
+struct aml_tuning_para {
+	unsigned int chip_id[4];
+	unsigned int magic;
+	unsigned int vddee;
+	struct hs400_para hs4[7];
+	struct hs200_para hs2;
+	struct hs_para hs;
+	unsigned int version;
+	unsigned int busmode;
+	unsigned int update;
+	int temperature;
+	long long checksum;
+
+};
+
+struct meson_host {
+	struct	device		*dev;
+	struct	meson_mmc_data *data;
+	struct	mmc_host	*mmc;
+	struct	mmc_command	*cmd;
+
+	void __iomem *regs;
+	void __iomem *pin_mux_base;
+	void __iomem *clk_tree_base;
+	struct resource *res[3];
+	struct clk *core_clk;
+	struct clk *tx_clk;
+	struct clk *mmc_clk;
+	struct clk *mux[2];
+	struct clk *mux_clk;
+	struct clk *mux1_in;
+	struct clk *clk[3];
+	unsigned long req_rate;
+	bool ddr;
+
+	bool dram_access_quirk;
+
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pins_default;
+	struct pinctrl_state *pins_clk_gate;
+
+	unsigned int bounce_buf_size;
+	void *bounce_buf;
+	dma_addr_t bounce_dma_addr;
+	struct sd_emmc_desc *descs;
+	dma_addr_t descs_dma_addr;
+	void __iomem *bounce_iomem_buf;
+
+	int irq;
+
+	bool vqmmc_enabled;
+	struct para_e sdmmc;
+	char is_tuning;
+	unsigned int delay_cell;
+	bool needs_pre_post_req;
+	int sd_sdio_switch_volat_done;
+	int irq_sdio_sleep;
+	int sdio_irqen;
+	unsigned int emmc_boot_base;
+	u32 pin_mux_val;
+	u32 clk_tree_val;
+	u32 host_clk_val;
+	int debug_flag;
+	unsigned int card_type;
+	unsigned int card_insert;
+	u8 fixadj_have_hole;
+	struct meson_mmc_hole hole[3];
+	u8 fix_hole;
+	u64 align[10];
+	u32 reg_bak[20];
+	u32 resume_clk;
+	char cmd_retune;
+	unsigned int win_start;
+	u8 *blk_test;
+	u8 *adj_win;
+	unsigned int cmd_c;
+	int cd_irq;
+	irqreturn_t (*cd_gpio_isr)(int irq, void *dev_id);
+	int is_uart;
+	int sd_uart_init;
+	int first_temp_index;
+	int cur_temp_index;
+	int compute_cmd_delay;
+	int compute_coef;
+	unsigned int save_para;
+	unsigned int src_clk_rate;
+	struct aml_tuning_para para;
+	int run_pxp_flag;
+	int nwr_cnt;
+	bool ignore_desc_busy;
+	bool use_intf3_tuning;
+	bool enable_hwcq;
+	int flags;
+	spinlock_t lock; /* lock for claim and bus ops */
+	bool src_clk_cfg_done;
+	bool ctrl_pwr_flag;
+	struct dentry *debugfs_root;
+};
+
+int sdio_reset_comm(struct mmc_card *card);
+void sdio_reinit(void);
+const char *get_wifi_inf(void);
+int sdio_get_vendor(void);
+void aml_host_bus_fsm_show(struct mmc_host *mmc, int status);
+
+#define   DRIVER_NAME "meson-gx-mmc"
+
+#define	  SD_EMMC_CLOCK 0x0
+#define   CLK_DIV_MASK GENMASK(5, 0)
+#define   CLK_SRC_MASK GENMASK(7, 6)
+#define   CLK_CORE_PHASE_MASK GENMASK(9, 8)
+#define   CLK_TX_PHASE_MASK GENMASK(11, 10)
+#define   CLK_RX_PHASE_MASK GENMASK(13, 12)
+#define   CLK_PHASE_0 0
+#define   CLK_PHASE_180 2
+#define   CLK_V2_TX_DELAY_MASK GENMASK(19, 16)
+#define   CLK_V2_RX_DELAY_MASK GENMASK(23, 20)
+#define   CLK_V2_ALWAYS_ON BIT(24)
+
+#define   CLK_V3_TX_DELAY_MASK GENMASK(21, 16)
+#define   CLK_V3_RX_DELAY_MASK GENMASK(27, 22)
+#define   CLK_V3_ALWAYS_ON BIT(28)
+#define   CFG_IRQ_SDIO_SLEEP BIT(29)
+#define   CFG_IRQ_SDIO_SLEEP_DS BIT(30)
+
+#define   CLK_TX_DELAY_MASK(h)    ((h)->data->tx_delay_mask)
+#define   CLK_RX_DELAY_MASK(h)    ((h)->data->rx_delay_mask)
+#define   CLK_ALWAYS_ON(h)        ((h)->data->always_on)
+
+#define SD_EMMC_DELAY 0x4
+
+#define SD_EMMC_ADJUST 0x8
+#define   ADJUST_ADJ_DELAY_MASK GENMASK(21, 16)
+#define   ADJUST_DS_EN BIT(15)
+#define   ADJUST_ADJ_EN BIT(13)
+
+#define SD_EMMC_DELAY1 0x4
+#define SD_EMMC_DELAY2 0x8
+#define SD_EMMC_V3_ADJUST 0xc
+#define	  CALI_SEL_MASK GENMASK(11, 8)
+#define	  CALI_ENABLE BIT(12)
+#define	  CFG_ADJUST_ENABLE BIT(13)
+#define	  CALI_RISE BIT(14)
+#define	  DS_ENABLE BIT(15)
+#define	  CLK_ADJUST_DELAY GENMASK(21, 16)
+#define	  ADJ_AUTO BIT(22)
+
+#define SD_EMMC_CALOUT 0x10
+#define SD_EMMC_ADJ_IDX_LOG 0x20
+#define SD_EMMC_CLKTEST_LOG 0x24
+#define   CLKTEST_TIMES_MASK GENMASK(30, 0)
+#define   CLKTEST_DONE BIT(31)
+#define SD_EMMC_CLKTEST_OUT 0x28
+#define SD_EMMC_EYETEST_LOG 0x2c
+#define   EYETEST_TIMES_MASK GENMASK(30, 0)
+#define   EYETEST_DONE BIT(31)
+#define SD_EMMC_EYETEST_OUT0 0x30
+#define SD_EMMC_EYETEST_OUT1 0x34
+#define SD_EMMC_INTF3 0x38
+#define   CLKTEST_EXP_MASK GENMASK(4, 0)
+#define   CLKTEST_ON_M BIT(5)
+#define   EYETEST_EXP_MASK GENMASK(10, 6)
+#define   EYETEST_ON BIT(11)
+#define   DS_SHT_M_MASK GENMASK(17, 12)
+#define   DS_SHT_EXP_MASK GENMASK(21, 18)
+#define   SD_INTF3 BIT(22)
+
+#define   EYETEST_SEL BIT(26)
+#define   RESP_SEL BIT(27)
+#define   CFG_RX_SEL BIT(26)
+#define   CFG_RX_PN BIT(27)
+#define   RESP_OLD BIT(28)
+#define   RESP_PN BIT(29)
+#define   RESP_DS BIT(30)
+
+#define SD_EMMC_START 0x40
+#define   START_DESC_INIT BIT(0)
+#define   START_DESC_BUSY BIT(1)
+#define   START_DESC_ADDR_MASK GENMASK(31, 2)
+
+#define SD_EMMC_CFG 0x44
+#define   CFG_BUS_WIDTH_MASK GENMASK(1, 0)
+#define   CFG_BUS_WIDTH_1 0x0
+#define   CFG_BUS_WIDTH_4 0x1
+#define   CFG_BUS_WIDTH_8 0x2
+#define   CFG_DDR BIT(2)
+#define   CFG_BLK_LEN_MASK GENMASK(7, 4)
+#define   CFG_RESP_TIMEOUT_MASK GENMASK(11, 8)
+#define   CFG_RC_CC_MASK GENMASK(15, 12)
+#define   CFG_STOP_CLOCK BIT(22)
+#define   CFG_CLK_ALWAYS_ON BIT(18)
+#define   CFG_CHK_DS BIT(20)
+#define   CFG_AUTO_CLK BIT(23)
+#define   CFG_ERR_ABORT BIT(27)
+
+#define SD_EMMC_STATUS 0x48
+#define   STATUS_BUSY BIT(31)
+#define   STATUS_DESC_BUSY BIT(30)
+#define   STATUS_DATI GENMASK(23, 16)
+
+#define SD_EMMC_IRQ_EN 0x4c
+#define   IRQ_RXD_ERR_MASK GENMASK(7, 0)
+#define   IRQ_TXD_ERR BIT(8)
+#define   IRQ_DESC_ERR BIT(9)
+#define   IRQ_RESP_ERR BIT(10)
+#define   IRQ_CRC_ERR \
+	(IRQ_RXD_ERR_MASK | IRQ_TXD_ERR | IRQ_DESC_ERR | IRQ_RESP_ERR)
+#define   IRQ_RESP_TIMEOUT BIT(11)
+#define   IRQ_DESC_TIMEOUT BIT(12)
+#define   IRQ_TIMEOUTS \
+	(IRQ_RESP_TIMEOUT | IRQ_DESC_TIMEOUT)
+#define   IRQ_END_OF_CHAIN BIT(13)
+#define   IRQ_RESP_STATUS BIT(14)
+#define   IRQ_SDIO BIT(15)
+#define   CFG_CMD_SETUP BIT(17)
+#define   BUS_FSM_MASK GENMASK(29, 26)
+#define   IRQ_EN_MASK \
+	(IRQ_CRC_ERR | IRQ_TIMEOUTS | IRQ_END_OF_CHAIN | IRQ_RESP_STATUS |\
+	 IRQ_SDIO)
+
+#define SD_EMMC_CMD_CFG 0x50
+#define SD_EMMC_CMD_ARG 0x54
+#define SD_EMMC_CMD_DAT 0x58
+#define SD_EMMC_CMD_RSP 0x5c
+#define SD_EMMC_CMD_RSP1 0x60
+#define SD_EMMC_CMD_RSP2 0x64
+#define SD_EMMC_CMD_RSP3 0x68
+
+#define SD_EMMC_RXD 0x94
+#define SD_EMMC_TXD 0x94
+#define SD_EMMC_LAST_REG SD_EMMC_TXD
+
+#define SD_EMMC_SRAM_DESC_BUF_OFF 0x200
+#define SD_EMMC_SRAM_DATA_BUF_LEN 1024
+#define SD_EMMC_SRAM_DATA_BUF_OFF 0x400
+#define SD_EMMC_MAX_SEGS 256
+#define SD_EMMC_MAX_REQ_SIZE (128 * 1024)
+#define SD_EMMC_MAX_SEG_SIZE (64 * 1024)
+
+#define SD_EMMC_CFG_BLK_SIZE 512 /* internal buffer max: 512 bytes */
+#define SD_EMMC_CFG_RESP_TIMEOUT 256 /* in clock cycles */
+#define SD_EMMC_CMD_TIMEOUT 1024 /* in ms */
+#define SD_EMMC_CMD_TIMEOUT_DATA 4096 /* in ms */
+#define SD_EMMC_CFG_CMD_GAP 16 /* in clock cycles */
+#define SD_EMMC_DESC_BUF_LEN PAGE_SIZE
+
+#define SD_EMMC_PRE_REQ_DONE BIT(0)
+#define SD_EMMC_DESC_CHAIN_MODE BIT(1)
+
+#define MUX_CLK_NUM_PARENTS 2
+
+#define CMD_CFG_LENGTH_MASK GENMASK(8, 0)
+#define CMD_CFG_BLOCK_MODE BIT(9)
+#define CMD_CFG_R1B BIT(10)
+#define CMD_CFG_END_OF_CHAIN BIT(11)
+#define CMD_CFG_TIMEOUT_MASK GENMASK(15, 12)
+#define CMD_CFG_NO_RESP BIT(16)
+#define CMD_CFG_NO_CMD BIT(17)
+#define CMD_CFG_DATA_IO BIT(18)
+#define CMD_CFG_DATA_WR BIT(19)
+#define CMD_CFG_RESP_NOCRC BIT(20)
+#define CMD_CFG_RESP_128 BIT(21)
+#define CMD_CFG_RESP_NUM BIT(22)
+#define CMD_CFG_DATA_NUM BIT(23)
+#define CMD_CFG_CMD_INDEX_MASK GENMASK(29, 24)
+#define CMD_CFG_ERROR BIT(30)
+#define CMD_CFG_OWNER BIT(31)
+
+#define CMD_DATA_MASK GENMASK(31, 2)
+#define CMD_DATA_BIG_ENDIAN BIT(1)
+#define CMD_DATA_SRAM BIT(0)
+#define CMD_RESP_MASK GENMASK(31, 1)
+#define CMD_RESP_SRAM BIT(0)
+#define EMMC_SDIO_CLOCK_FELD    0Xffff
+#define CALI_HS_50M_ADJUST      0
+#define ERROR   1
+#define FIXED   2
+#define		SZ_1M			0x00100000
+#define	MMC_PATTERN_NAME		"pattern"
+#define	MMC_PATTERN_OFFSET		((SZ_1M * (36 + 3)) / 512)
+#define	MMC_MAGIC_NAME			"magic"
+#define	MMC_MAGIC_OFFSET		((SZ_1M * (36 + 6)) / 512)
+#define	MMC_RANDOM_NAME			"random"
+#define	MMC_RANDOM_OFFSET		((SZ_1M * (36 + 7)) / 512)
+#define	MMC_DTB_NAME			"dtb"
+#define	MMC_DTB_OFFSET			((SZ_1M * (36 + 4)) / 512)
+#define CALI_BLK_CNT	80
+#define CALI_HS_50M_ADJUST	0
+#define EMMC_SDIO_CLOCK_FELD	0Xffff
+#define MMC_PM_TIMEOUT	(2000)
+#define ERROR	1
+#define FIXED	2
+#define RETUNING	3
+#define	DATA3_PINMUX_MASK GENMASK(15, 12)
+
+#define NBITS_FIX_ADJ	(64)
+#define TUNING_NUM_PER_POINT 40
+#define MAX_TUNING_RETRY 4
+#define AML_FIXED_ADJ_MAX 8
+#define AML_FIXED_ADJ_MIN 5
+#define AML_FIXADJ_STEP 4
+#define ADJ_WIN_PRINT_MAXLEN 256
+#define NO_FIXED_ADJ_MID BIT(31)
+#define AML_MV_DLY2_NOMMC_CMD(x) ((x) << 24)
+
+#define SD_EMMC_FIXED_ADJ_HS200
+#define EMMC_CMD_WIN_MAX_SIZE	50
+#define EMMC_CMD_WIN_FULL_SIZE	64
+
+#define DBG_COMMON        BIT(0)
+#define DBG_HS200         BIT(1)
+#define Print_dbg(dbg_level, fmt, args...) do {\
+		if ((dbg_level) & mmc_debug)	\
+			pr_info("[%s]" fmt, __func__, ##args);	\
+} while (0)
+
+/* delay_cell=70ps,1ns/delay_cell */
+#define DELAY_CELL_COUNTS 14
+
+/* Host attributes */
+#define AML_USE_64BIT_DMA        BIT(0)
+
+#endif /*__AML_SD_H__*/
+
diff -urN linux-5.10.y-a/include/linux/amlogic/bt_device.h linux-5.10.y-b/include/linux/amlogic/bt_device.h
--- linux-5.10.y-a/include/linux/amlogic/bt_device.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/include/linux/amlogic/bt_device.h	2022-11-27 09:30:04.000000000 +0800
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef __PLAT_MESON_BT_DEVICE_H
+#define __PLAT_MESON_BT_DEVICE_H
+
+struct bt_dev_data {
+	int gpio_reset;
+	int gpio_en;
+	int gpio_hostwake;
+	int gpio_btwakeup;
+	int power_low_level;
+	int power_on_pin_OD;
+	int power_off_flag;
+	int power_down_disable;
+	int irqno_wakeup;
+	struct work_struct btwakeup_work;
+	struct input_dev *input_dev;
+	struct hrtimer timer;
+};
+
+int sdio_get_vendor(void);
+
+#endif
diff -urN linux-5.10.y-a/include/linux/amlogic/cpu_version.h linux-5.10.y-b/include/linux/amlogic/cpu_version.h
--- linux-5.10.y-a/include/linux/amlogic/cpu_version.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/include/linux/amlogic/cpu_version.h	2022-11-27 09:30:04.000000000 +0800
@@ -0,0 +1,5 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+#include <linux/amlogic/media/registers/cpu_version.h>
diff -urN linux-5.10.y-a/include/linux/amlogic/dhd_buf.h linux-5.10.y-b/include/linux/amlogic/dhd_buf.h
--- linux-5.10.y-a/include/linux/amlogic/dhd_buf.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/include/linux/amlogic/dhd_buf.h	2022-11-27 09:30:04.000000000 +0800
@@ -0,0 +1,9 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef _BCMDHD_BUF_H
+#define _BCMDHD_BUF_H
+int bcmdhd_init_wlan_mem(unsigned int all_buf);
+#endif
diff -urN linux-5.10.y-a/include/linux/amlogic/iomap.h linux-5.10.y-b/include/linux/amlogic/iomap.h
--- linux-5.10.y-a/include/linux/amlogic/iomap.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/include/linux/amlogic/iomap.h	2022-11-27 09:30:04.000000000 +0800
@@ -0,0 +1,78 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * include/linux/amlogic/iomap.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __SOC_IO_H
+#define __SOC_IO_H
+
+#include <linux/amlogic/media/registers/register_map.h>
+#include <linux/io.h>
+
+/* vpp simple io */
+static inline int aml_read_vcbus_s(unsigned int reg)
+{
+	return readl((vpp_base + (reg << 2)));
+}
+
+static inline void aml_write_vcbus_s(unsigned int reg, unsigned int val)
+{
+	writel(val, (vpp_base + (reg << 2)));
+}
+
+static inline void aml_vcbus_update_bits_s(unsigned int reg,
+					   unsigned int value,
+					   unsigned int start,
+					   unsigned int len)
+{
+	unsigned int tmp, orig;
+	unsigned int mask = (((1L << len) - 1) << start);
+	int r = (reg << 2);
+
+	orig =  readl((vpp_base + r));
+	tmp = orig  & ~mask;
+	tmp |= (value << start) & mask;
+	writel(tmp, (vpp_base + r));
+}
+
+/* hiu simple io */
+static inline int aml_read_hiubus_s(unsigned int reg)
+{
+	return readl((hiu_base + (reg << 2)));
+}
+
+static inline void aml_write_hiubus_s(unsigned int reg,
+				      unsigned int val)
+{
+	writel(val, (hiu_base + (reg << 2)));
+}
+
+static inline void aml_hiubus_update_bits_s(unsigned int reg,
+					    unsigned int value,
+					    unsigned int start,
+					    unsigned int len)
+{
+	unsigned int tmp, orig;
+	unsigned int mask = (((1L << len) - 1) << start);
+	int r = (reg << 2);
+
+	orig =  readl((hiu_base + r));
+	tmp = orig  & ~mask;
+	tmp |= (value << start) & mask;
+	writel(tmp, (hiu_base + r));
+}
+
+#endif
diff -urN linux-5.10.y-a/include/linux/amlogic/key_manage.h linux-5.10.y-b/include/linux/amlogic/key_manage.h
--- linux-5.10.y-a/include/linux/amlogic/key_manage.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/include/linux/amlogic/key_manage.h	2022-11-01 20:35:50.000000000 +0800
@@ -0,0 +1,28 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef __KEYMANAGE__
+#define __KEYMANAGE__
+
+enum {
+	UNIFYKEY_STORAGE_TYPE_INVALID = 0,
+	UNIFYKEY_STORAGE_TYPE_EMMC,
+	UNIFYKEY_STORAGE_TYPE_NAND,
+	UNIFYKEY_STORAGE_TYPE_MAX
+};
+
+struct unifykey_storage_ops {
+	s32 (*read)(u8 *buf, u32 len, u32 *actual_len);
+	s32 (*write)(u8 *buf, u32 len, u32 *actual_len);
+};
+
+struct unifykey_type {
+	u32 storage_type;
+	struct unifykey_storage_ops *ops;
+};
+
+int register_unifykey_types(struct unifykey_type *uk_type);
+
+#endif /*__KEYMANAGE__*/
diff -urN linux-5.10.y-a/include/linux/amlogic/media/registers/cpu_version.h linux-5.10.y-b/include/linux/amlogic/media/registers/cpu_version.h
--- linux-5.10.y-a/include/linux/amlogic/media/registers/cpu_version.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/include/linux/amlogic/media/registers/cpu_version.h	2022-11-27 09:30:04.000000000 +0800
@@ -0,0 +1,293 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef __REGISTERS_MESON_CPU_H
+#define __REGISTERS_MESON_CPU_H
+
+#define MESON_CPU_TYPE_MESON1		0x10
+#define MESON_CPU_TYPE_MESON2		0x20
+#define MESON_CPU_TYPE_MESON3		0x30
+#define MESON_CPU_TYPE_MESON6		0x60
+#define MESON_CPU_TYPE_MESON6TV		0x70
+#define MESON_CPU_TYPE_MESON6TVD	0x75
+#define MESON_CPU_TYPE_MESON8		0x80
+#define MESON_CPU_TYPE_MESON8B		0x8B
+#define MESON_CPU_TYPE_MESONG9TV	0x90
+
+/*
+ *	Read back value for P_ASSIST_HW_REV
+ *
+ *	Please note: M8M2 readback value same as M8 (0x19)
+ *			     We changed it to 0x1D in software,
+ *			     Please ALWAYS use get_meson_cpu_version()
+ *			     to get the version of Meson CPU
+ */
+#define MESON_CPU_MAJOR_ID_M6		0x16
+#define MESON_CPU_MAJOR_ID_M6TV		0x17
+#define MESON_CPU_MAJOR_ID_M6TVL	0x18
+#define MESON_CPU_MAJOR_ID_M8		0x19
+#define MESON_CPU_MAJOR_ID_MTVD		0x1A
+#define MESON_CPU_MAJOR_ID_MG9TV	0x1C
+#define MESON_CPU_MAJOR_ID_M8M2		0x1D
+
+#define MESON_CPU_VERSION_LVL_PACK	2
+
+enum meson_cpuid_type_e {
+	MESON_CPU_MAJOR_ID_M8B = 0x1B,
+	MESON_CPU_MAJOR_ID_GXBB = 0x1F,
+	MESON_CPU_MAJOR_ID_GXTVBB,
+	MESON_CPU_MAJOR_ID_GXL,
+	MESON_CPU_MAJOR_ID_GXM,
+	MESON_CPU_MAJOR_ID_TXL,
+	MESON_CPU_MAJOR_ID_TXLX,
+	MESON_CPU_MAJOR_ID_AXG,
+	MESON_CPU_MAJOR_ID_GXLX,
+	MESON_CPU_MAJOR_ID_TXHD,
+	MESON_CPU_MAJOR_ID_G12A,
+	MESON_CPU_MAJOR_ID_G12B,
+	MESON_CPU_MAJOR_ID_SM1 = 0x2B,
+	MESON_CPU_MAJOR_ID_TL1 = 0x2E,
+	MESON_CPU_MAJOR_ID_TM2,
+	MESON_CPU_MAJOR_ID_C1,
+	MESON_CPU_MAJOR_ID_SC2 = 0x32,
+	MESON_CPU_MAJOR_ID_T5 = 0x34,
+	MESON_CPU_MAJOR_ID_T5D = 0x35,
+	MESON_CPU_MAJOR_ID_T7 = 0x36,
+	MESON_CPU_MAJOR_ID_S4 = 0x37,
+	MESON_CPU_MAJOR_ID_T3 = 0x38,
+	MESON_CPU_MAJOR_ID_S4D = 0x3a,
+	MESON_CPU_MAJOR_ID_UNKNOWN,
+};
+
+#define MESON_CPU_VERSION_LVL_MAJOR	0
+#define MESON_CPU_VERSION_LVL_MINOR	1
+#define MESON_CPU_VERSION_LVL_PACK	2
+#define MESON_CPU_VERSION_LVL_MISC	3
+#define MESON_CPU_VERSION_LVL_MAX	MESON_CPU_VERSION_LVL_MISC
+
+struct codecio_device_data_s {
+	enum meson_cpuid_type_e cpu_id;
+};
+
+int meson_cpu_version_init(void);
+int get_cpu_type_from_media(void);
+
+unsigned char get_meson_cpu_version(int level);
+
+static inline int get_cpu_type(void)
+{
+	int cpu_id_from_media = 0;
+
+	cpu_id_from_media = get_cpu_type_from_media();
+	if (cpu_id_from_media)
+		return cpu_id_from_media;
+	return get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR);
+}
+
+static inline u32 get_cpu_package(void)
+{
+	unsigned int pk;
+
+	pk = get_meson_cpu_version(MESON_CPU_VERSION_LVL_PACK) & 0xF0;
+	return pk;
+}
+
+static inline bool package_id_is(unsigned int id)
+{
+	return get_cpu_package() == id;
+}
+
+static inline bool is_meson_m8_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_M8;
+}
+
+static inline bool is_meson_mtvd_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_MTVD;
+}
+
+static inline bool is_meson_m8m2_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_M8M2;
+}
+
+static inline bool is_meson_g9tv_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_MG9TV;
+}
+
+/* new added*/
+static inline bool is_meson_m8b_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_M8B;
+}
+
+static inline bool is_meson_gxbb_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXBB;
+}
+
+static inline bool is_meson_gxtvbb_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB;
+}
+
+static inline bool is_meson_gxl_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXL;
+}
+
+static inline bool is_meson_gxl_package_905D(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0x0);
+}
+
+static inline bool is_meson_gxl_package_905X(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0x80);
+}
+
+static inline bool is_meson_gxl_package_905L(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0xc0);
+}
+
+static inline bool is_meson_gxl_package_905M2(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0xe0);
+}
+
+static inline bool is_meson_gxl_package_805X(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0x30);
+}
+
+static inline bool is_meson_gxl_package_805Y(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0xb0);
+}
+
+static inline bool is_meson_gxm_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXM;
+}
+
+static inline bool is_meson_txl_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_TXL;
+}
+
+static inline bool is_meson_txlx_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_TXLX;
+}
+
+static inline bool is_meson_axg_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_AXG;
+}
+
+static inline bool is_meson_gxlx_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXLX;
+}
+
+static inline bool is_meson_txhd_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_TXHD;
+}
+
+static inline bool is_meson_g12a_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_G12A;
+}
+
+static inline bool is_meson_g12b_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_G12B;
+}
+
+static inline bool is_meson_sm1_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_SM1;
+}
+
+static inline bool is_meson_tl1_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_TL1;
+}
+
+static inline bool is_meson_tm2_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_TM2;
+}
+
+static inline bool is_meson_sc2_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_SC2;
+}
+
+static inline bool is_meson_t5_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_T5;
+}
+
+static inline bool is_meson_t5d_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_T5D;
+}
+
+static inline bool is_meson_t7_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_T7;
+}
+
+static inline bool is_meson_s4_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_S4;
+}
+
+static inline bool is_meson_t3_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_T3;
+}
+
+static inline bool is_meson_s4d_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_S4D;
+}
+
+static inline bool cpu_after_eq(unsigned int id)
+{
+	return get_cpu_type() >= id;
+}
+
+static inline bool is_meson_txlx_package_962X(void)
+{
+	return is_meson_txlx_cpu() && package_id_is(0x10);
+}
+
+static inline bool is_meson_txlx_package_962E(void)
+{
+	return is_meson_txlx_cpu() && package_id_is(0x20);
+}
+
+static inline bool is_meson_rev_a(void)
+{
+	return (get_meson_cpu_version(MESON_CPU_VERSION_LVL_MINOR) == 0xA);
+}
+
+static inline bool is_meson_rev_b(void)
+{
+	return (get_meson_cpu_version(MESON_CPU_VERSION_LVL_MINOR) == 0xB);
+}
+
+static inline bool is_meson_rev_c(void)
+{
+	return (get_meson_cpu_version(MESON_CPU_VERSION_LVL_MINOR) == 0xC);
+}
+
+#endif
diff -urN linux-5.10.y-a/include/linux/amlogic/media/registers/register_map.h linux-5.10.y-b/include/linux/amlogic/media/registers/register_map.h
--- linux-5.10.y-a/include/linux/amlogic/media/registers/register_map.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/include/linux/amlogic/media/registers/register_map.h	2022-11-27 09:30:04.000000000 +0800
@@ -0,0 +1,105 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef CODECIO_REGISTER_MAP_H
+#define CODECIO_REGISTER_MAP_H
+
+#include <linux/io.h>
+
+enum {
+	CODECIO_CBUS_BASE = 0,
+	CODECIO_DOSBUS_BASE,
+	CODECIO_HIUBUS_BASE,
+	CODECIO_AOBUS_BASE,
+	CODECIO_VCBUS_BASE,
+	CODECIO_DMCBUS_BASE,
+	CODECIO_EFUSE_BASE,
+	CODECIO_BUS_MAX,
+};
+
+extern void __iomem *vpp_base;
+extern void __iomem *hiu_base;
+extern uint codecio_reg_start[CODECIO_BUS_MAX];
+
+int codecio_read_cbus(unsigned int reg);
+void codecio_write_cbus(unsigned int reg, unsigned int val);
+int codecio_read_dosbus(unsigned int reg);
+void codecio_write_dosbus(unsigned int reg, unsigned int val);
+int codecio_read_hiubus(unsigned int reg);
+void codecio_write_hiubus(unsigned int reg, unsigned int val);
+int codecio_read_aobus(unsigned int reg);
+void codecio_write_aobus(unsigned int reg, unsigned int val);
+int codecio_read_vcbus(unsigned int reg);
+void codecio_write_vcbus(unsigned int reg, unsigned int val);
+int codecio_read_dmcbus(unsigned int reg);
+void codecio_write_dmcbus(unsigned int reg, unsigned int val);
+int codecio_read_parsbus(unsigned int reg);
+void codecio_write_parsbus(unsigned int reg, unsigned int val);
+int codecio_read_aiubus(unsigned int reg);
+void codecio_write_aiubus(unsigned int reg, unsigned int val);
+int codecio_read_demuxbus(unsigned int reg);
+void codecio_write_demuxbus(unsigned int reg, unsigned int val);
+int codecio_read_resetbus(unsigned int reg);
+void codecio_write_resetbus(unsigned int reg, unsigned int val);
+int codecio_read_efusebus(unsigned int reg);
+void codecio_write_efusebus(unsigned int reg, unsigned int val);
+
+int aml_reg_read(u32 bus_type, unsigned int reg, unsigned int *val);
+int aml_reg_write(u32 bus_type, unsigned int reg, unsigned int val);
+int aml_regmap_update_bits(u32 bus_type,
+			   unsigned int reg,
+			   unsigned int mask,
+			   unsigned int val);
+/*
+ ** CBUS REG Read Write and Update some bits
+ */
+int aml_read_cbus(unsigned int reg);
+void aml_write_cbus(unsigned int reg, unsigned int val);
+void aml_cbus_update_bits(unsigned int reg,
+			  unsigned int mask,
+			  unsigned int val);
+/*
+ ** AO REG Read Write and Update some bits
+ */
+int aml_read_aobus(unsigned int reg);
+void aml_write_aobus(unsigned int reg, unsigned int val);
+void aml_aobus_update_bits(unsigned int reg,
+			   unsigned int mask,
+			   unsigned int val);
+/*
+ ** VCBUS Bus REG Read Write and Update some bits
+ */
+int aml_read_vcbus(unsigned int reg);
+void aml_write_vcbus(unsigned int reg, unsigned int val);
+void aml_vcbus_update_bits(unsigned int reg,
+			   unsigned int mask,
+			   unsigned int val);
+/*
+ ** DOS BUS Bus REG Read Write and Update some bits
+ */
+int aml_read_dosbus(unsigned int reg);
+void aml_write_dosbus(unsigned int reg, unsigned int val);
+void aml_dosbus_update_bits(unsigned int reg,
+			    unsigned int mask, unsigned int val);
+int  aml_read_sec_reg(unsigned int reg);
+void  aml_write_sec_reg(unsigned int reg, unsigned int val);
+
+/*
+ ** HIUBUS REG Read Write and Update some bits
+ */
+int aml_read_hiubus(unsigned int reg);
+void aml_write_hiubus(unsigned int reg, unsigned int val);
+void aml_hiubus_update_bits(unsigned int reg,
+			    unsigned int mask, unsigned int val);
+
+/*
+ ** DMCBUS REG Read Write and Update some bits
+ */
+int aml_read_dmcbus(unsigned int reg);
+void aml_write_dmcbus(unsigned int reg, unsigned int val);
+void aml_dmcbus_update_bits(unsigned int reg,
+			    unsigned int mask, unsigned int val);
+
+#endif
diff -urN linux-5.10.y-a/include/linux/amlogic/pm.h linux-5.10.y-b/include/linux/amlogic/pm.h
--- linux-5.10.y-a/include/linux/amlogic/pm.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/include/linux/amlogic/pm.h	2022-11-27 09:30:04.000000000 +0800
@@ -0,0 +1,79 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef __AML_PM_H__
+#define __AML_PM_H__
+#include <linux/notifier.h>
+
+/* wake up reason*/
+#define	UDEFINED_WAKEUP		0
+#define	CHARGING_WAKEUP		1
+#define	REMOTE_WAKEUP		2
+#define	RTC_WAKEUP		3
+#define	BT_WAKEUP		4
+#define	WIFI_WAKEUP		5
+#define	POWER_KEY_WAKEUP	6
+#define	AUTO_WAKEUP		7
+#define	CEC_WAKEUP		8
+#define	REMOTE_CUS_WAKEUP	9
+#define ETH_PHY_WAKEUP		10
+#define	CECB_WAKEUP	11
+#define	ETH_PHY_GPIO	12
+#define	VAD_WAKEUP	13
+unsigned int get_resume_method(void);
+unsigned int get_resume_reason(void);
+unsigned int is_pm_s2idle_mode(void);
+
+#ifdef CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND
+enum {
+	EARLY_SUSPEND_LEVEL_BLANK_SCREEN = 50,
+	EARLY_SUSPEND_LEVEL_STOP_DRAWING = 100,
+	EARLY_SUSPEND_LEVEL_DISABLE_FB = 150,
+};
+
+struct early_suspend {
+	struct list_head link;
+	int level;
+	void (*suspend)(struct early_suspend *h);
+	void (*resume)(struct early_suspend *h);
+	void *param;
+};
+
+void register_early_suspend(struct early_suspend *handler);
+void unregister_early_suspend(struct early_suspend *handler);
+unsigned int lgcy_early_suspend_init(struct platform_device *pdev);
+
+#endif //CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND
+
+#ifdef CONFIG_AMLOGIC_M8B_SUSPEND
+/*l2c virtual addr*/
+#define IO_PL310_BASE 0xfe000000
+
+/*IR, power key, low power,
+ *adapter plug in/out and so on,
+ *are all use this flag.
+ */
+#define FLAG_WAKEUP_PWRKEY		0x1234abcd
+#define FLAG_WAKEUP_ALARM		0x12345678
+#define FLAG_WAKEUP_WIFI		0x12340001
+#define FLAG_WAKEUP_BT			0x12340002
+#define FLAG_WAKEUP_PWROFF		0x12340003
+
+/*AOBUS*/
+#define AO_RTI_STATUS_REG2 0x0008
+#define AO_RTC_ADDR0 0x0740
+#define AO_RTC_ADDR1 0x0744
+#define AO_RTC_ADDR2 0x0748
+#define AO_RTC_ADDR3 0x074c
+#define AO_UART_STATUS 0x04cc
+#define AO_UART_REG5   0x04d4
+
+/*CBUS*/
+#define HHI_SYS_PLL_CNTL  0x10c0
+#define HHI_MPEG_CLK_CNTL 0x105d
+
+#endif //CONFIG_AMLOGIC_M8B_SUSPEND
+
+#endif //__AML_PM_H__
Binary files linux-5.10.y-a/include/linux/amlogic/._pwm-meson.h and linux-5.10.y-b/include/linux/amlogic/._pwm-meson.h differ
diff -urN linux-5.10.y-a/include/linux/amlogic/pwm-meson.h linux-5.10.y-b/include/linux/amlogic/pwm-meson.h
--- linux-5.10.y-a/include/linux/amlogic/pwm-meson.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/include/linux/amlogic/pwm-meson.h	2022-12-21 15:53:36.000000000 +0800
@@ -0,0 +1,153 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef _PWM_MESON_H
+#define _PWM_MESON_H
+
+#include <linux/bitops.h>
+#include <linux/export.h>
+#include <linux/io.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <linux/mutex.h>
+#include <linux/time.h>
+#include <linux/of_address.h>
+#include <linux/clk-provider.h>
+#include <linux/regmap.h>
+/* for pwm channel index*/
+#include <dt-bindings/pwm/meson.h>
+
+#define MESON_NUM_PWMS		2
+#define MESON_DOUBLE_NUM_PWMS	4
+#define DEFAULT_EXTERN_CLK	24000000
+
+
+/*a group pwm registers offset address
+ * for example:
+ * PWM A B
+ * PWM C D
+ * PWM E F
+ * PWM AO A
+ * PWM AO B
+ */
+#define REG_PWM_A				0x0
+#define REG_PWM_B				0x4
+#define REG_MISC_AB				0x8
+#define REG_DS_AB				0xc
+#define REG_TIME_AB				0x10
+#define REG_PWM_A2				0x14
+#define REG_PWM_B2				0x18
+#define REG_BLINK_AB				0x1c
+
+#define PWM_LOW_MASK				GENMASK(15, 0)
+#define PWM_HIGH_MASK				GENMASK(31, 16)
+
+/* pwm output enable */
+#define MISC_A_EN				BIT(0)
+#define MISC_B_EN				BIT(1)
+#define MISC_A2_EN				BIT(25)
+#define MISC_B2_EN				BIT(24)
+/* pwm polarity enable */
+#define MISC_A_INVERT				BIT(26)
+#define MISC_B_INVERT				BIT(27)
+/* when you want 0% or 100% waveform
+ * constant bit should be set.
+ */
+#define MISC_A_CONSTANT				BIT(28)
+#define MISC_B_CONSTANT				BIT(29)
+/*
+ * pwm a and b clock enable/disable
+ */
+#define MISC_A_CLK_EN				BIT(15)
+#define MISC_B_CLK_EN				BIT(23)
+/*
+ * blink control bit
+ */
+#define BLINK_A					BIT(8)
+#define BLINK_B					BIT(9)
+
+#define PWM_HIGH_SHIFT				16
+#define MISC_CLK_DIV_MASK			0x7f
+#define MISC_B_CLK_DIV_SHIFT			16
+#define MISC_A_CLK_DIV_SHIFT			8
+#define MISC_B_CLK_SEL_SHIFT			6
+#define MISC_A_CLK_SEL_SHIFT			4
+#define MISC_CLK_SEL_WIDTH			2
+#define PWM_CHANNELS_PER_GROUP			2
+#define PWM_DISABLE				0
+#define MISC_CLK_SEL_MASK			0x3
+
+static const unsigned int mux_reg_shifts[] = {
+	MISC_A_CLK_SEL_SHIFT,
+	MISC_B_CLK_SEL_SHIFT,
+	MISC_A_CLK_SEL_SHIFT,
+	MISC_B_CLK_SEL_SHIFT
+};
+
+/*pwm register att*/
+struct meson_pwm_variant {
+	unsigned int times;
+	unsigned int constant;
+	unsigned int blink_enable;
+	unsigned int blink_times;
+};
+
+/*for soc data:
+ *double channel enable
+ * double_channel = false ,could use PWM A
+ * double_channel = true , could use PWM A and PWM A2
+ * extern_clk = false , clk div, gate, mux in pwm controller
+ * extern_clk = true , clk div, gate, mux in clktree
+ */
+struct meson_pwm_data {
+	char **parent_names;
+	unsigned int num_parents;
+	unsigned int double_channel;
+	unsigned int extern_clk;
+};
+
+struct meson_pwm_channel {
+	unsigned int hi;
+	unsigned int lo;
+#ifdef CONFIG_AMLOGIC_MODIFY
+	unsigned int clk_rate;
+	u8 clk_div;
+#endif
+	u8 pre_div;
+
+	struct clk *clk_parent;
+	struct clk_mux mux;
+	struct clk *clk;
+};
+
+struct meson_pwm {
+	struct pwm_chip chip;
+	struct meson_pwm_data *data;
+	struct meson_pwm_channel channels[MESON_DOUBLE_NUM_PWMS];
+	struct meson_pwm_variant variant;
+	void __iomem *base;
+	/*
+	 * Protects register (write) access to the REG_MISC_AB register
+	 * that is shared between the two PWMs.
+	 */
+	spinlock_t lock;
+	struct regmap *regmap_base;
+};
+
+/*the functions only use for meson pwm driver*/
+int meson_pwm_sysfs_init(struct device *dev);
+void meson_pwm_sysfs_exit(struct device *dev);
+
+/*the functions use for special function in meson pwm driver*/
+int pwm_register_debug(struct meson_pwm *meson);
+struct meson_pwm *to_meson_pwm(struct pwm_chip *chip);
+int pwm_constant_enable(struct meson_pwm *meson, int index);
+int pwm_constant_disable(struct meson_pwm *meson, int index);
+int pwm_blink_enable(struct meson_pwm *meson, int index);
+int pwm_blink_disable(struct meson_pwm *meson, int index);
+int pwm_set_blink_times(struct meson_pwm *meson, int index, int value);
+int pwm_set_times(struct meson_pwm *meson, int index, int value);
+#endif   /* _PWM_MESON_H_ */
+
diff -urN linux-5.10.y-a/include/linux/amlogic/wifi_dt.h linux-5.10.y-b/include/linux/amlogic/wifi_dt.h
--- linux-5.10.y-a/include/linux/amlogic/wifi_dt.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/include/linux/amlogic/wifi_dt.h	2022-11-27 09:30:04.000000000 +0800
@@ -0,0 +1,27 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef _wifi_dt_h_
+#define _wifi_dt_h_
+
+void sdio_reinit(void);
+char *get_wifi_inf(void);
+
+void extern_wifi_set_enable(int is_on);
+int wifi_irq_num(void);
+void set_usb_bt_power(int is_power);
+
+#ifdef CONFIG_PCI
+/*amlogic 4.9 kernel support pci interface wifi*/
+void pci_lock_rescan_remove(void);
+struct pci_bus *pci_find_next_bus(const struct pci_bus *from);
+unsigned int pci_rescan_bus(struct pci_bus *bus);
+void pci_unlock_rescan_remove(void);
+struct pci_dev *pci_get_device(unsigned int vendor, unsigned int device,
+			       struct pci_dev *from);
+void pci_stop_and_remove_bus_device_locked(struct pci_dev *dev);
+#endif
+
+#endif /* _wifi_dt_h_ */
diff -urN linux-5.10.y-a/include/linux/dma-contiguous.h linux-5.10.y-b/include/linux/dma-contiguous.h
--- linux-5.10.y-a/include/linux/dma-contiguous.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-5.10.y-b/include/linux/dma-contiguous.h	2022-11-01 20:35:50.000000000 +0800
@@ -0,0 +1,176 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+#ifndef __LINUX_CMA_H
+#define __LINUX_CMA_H
+
+/*
+ * Contiguous Memory Allocator for DMA mapping framework
+ * Copyright (c) 2010-2011 by Samsung Electronics.
+ * Written by:
+ *	Marek Szyprowski <m.szyprowski@samsung.com>
+ *	Michal Nazarewicz <mina86@mina86.com>
+ */
+
+/*
+ * Contiguous Memory Allocator
+ *
+ *   The Contiguous Memory Allocator (CMA) makes it possible to
+ *   allocate big contiguous chunks of memory after the system has
+ *   booted.
+ *
+ * Why is it needed?
+ *
+ *   Various devices on embedded systems have no scatter-getter and/or
+ *   IO map support and require contiguous blocks of memory to
+ *   operate.  They include devices such as cameras, hardware video
+ *   coders, etc.
+ *
+ *   Such devices often require big memory buffers (a full HD frame
+ *   is, for instance, more then 2 mega pixels large, i.e. more than 6
+ *   MB of memory), which makes mechanisms such as kmalloc() or
+ *   alloc_page() ineffective.
+ *
+ *   At the same time, a solution where a big memory region is
+ *   reserved for a device is suboptimal since often more memory is
+ *   reserved then strictly required and, moreover, the memory is
+ *   inaccessible to page system even if device drivers don't use it.
+ *
+ *   CMA tries to solve this issue by operating on memory regions
+ *   where only movable pages can be allocated from.  This way, kernel
+ *   can use the memory for pagecache and when device driver requests
+ *   it, allocated pages can be migrated.
+ *
+ * Driver usage
+ *
+ *   CMA should not be used by the device drivers directly. It is
+ *   only a helper framework for dma-mapping subsystem.
+ *
+ *   For more information, see kernel-docs in kernel/dma/contiguous.c
+ */
+
+#ifdef __KERNEL__
+
+#include <linux/device.h>
+#include <linux/mm.h>
+
+struct cma;
+struct page;
+
+#ifdef CONFIG_DMA_CMA
+
+extern struct cma *dma_contiguous_default_area;
+
+static inline struct cma *dev_get_cma_area(struct device *dev)
+{
+	if (dev && dev->cma_area)
+		return dev->cma_area;
+	return dma_contiguous_default_area;
+}
+
+static inline void dev_set_cma_area(struct device *dev, struct cma *cma)
+{
+	if (dev)
+		dev->cma_area = cma;
+}
+
+static inline void dma_contiguous_set_default(struct cma *cma)
+{
+	dma_contiguous_default_area = cma;
+}
+
+void dma_contiguous_reserve(phys_addr_t addr_limit);
+
+int __init dma_contiguous_reserve_area(phys_addr_t size, phys_addr_t base,
+				       phys_addr_t limit, struct cma **res_cma,
+				       bool fixed);
+
+/**
+ * dma_declare_contiguous() - reserve area for contiguous memory handling
+ *			      for particular device
+ * @dev:   Pointer to device structure.
+ * @size:  Size of the reserved memory.
+ * @base:  Start address of the reserved memory (optional, 0 for any).
+ * @limit: End address of the reserved memory (optional, 0 for any).
+ *
+ * This function reserves memory for specified device. It should be
+ * called by board specific code when early allocator (memblock or bootmem)
+ * is still activate.
+ */
+
+static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,
+					 phys_addr_t base, phys_addr_t limit)
+{
+	struct cma *cma;
+	int ret;
+	ret = dma_contiguous_reserve_area(size, base, limit, &cma, true);
+	if (ret == 0)
+		dev_set_cma_area(dev, cma);
+
+	return ret;
+}
+
+struct page *dma_alloc_from_contiguous(struct device *dev, size_t count,
+				       unsigned int order, bool no_warn);
+bool dma_release_from_contiguous(struct device *dev, struct page *pages,
+				 int count);
+struct page *dma_alloc_contiguous(struct device *dev, size_t size, gfp_t gfp);
+void dma_free_contiguous(struct device *dev, struct page *page, size_t size);
+
+#else
+
+static inline struct cma *dev_get_cma_area(struct device *dev)
+{
+	return NULL;
+}
+
+static inline void dev_set_cma_area(struct device *dev, struct cma *cma) { }
+
+static inline void dma_contiguous_set_default(struct cma *cma) { }
+
+static inline void dma_contiguous_reserve(phys_addr_t limit) { }
+
+static inline int dma_contiguous_reserve_area(phys_addr_t size, phys_addr_t base,
+				       phys_addr_t limit, struct cma **res_cma,
+				       bool fixed)
+{
+	return -ENOSYS;
+}
+
+static inline
+int dma_declare_contiguous(struct device *dev, phys_addr_t size,
+			   phys_addr_t base, phys_addr_t limit)
+{
+	return -ENOSYS;
+}
+
+static inline
+struct page *dma_alloc_from_contiguous(struct device *dev, size_t count,
+				       unsigned int order, bool no_warn)
+{
+	return NULL;
+}
+
+static inline
+bool dma_release_from_contiguous(struct device *dev, struct page *pages,
+				 int count)
+{
+	return false;
+}
+
+/* Use fallback alloc() and free() when CONFIG_DMA_CMA=n */
+static inline struct page *dma_alloc_contiguous(struct device *dev, size_t size,
+		gfp_t gfp)
+{
+	return NULL;
+}
+
+static inline void dma_free_contiguous(struct device *dev, struct page *page,
+		size_t size)
+{
+	__free_pages(page, get_order(size));
+}
+
+#endif
+
+#endif
+
+#endif
Binary files linux-5.10.y-a/include/linux/._.DS_Store and linux-5.10.y-b/include/linux/._.DS_Store differ
Binary files linux-5.10.y-a/include/linux/.DS_Store and linux-5.10.y-b/include/linux/.DS_Store differ
Binary files linux-5.10.y-a/include/linux/mmc/._card.h and linux-5.10.y-b/include/linux/mmc/._card.h differ
Binary files linux-5.10.y-a/include/linux/mmc/._core.h and linux-5.10.y-b/include/linux/mmc/._core.h differ
diff -urN linux-5.10.y-a/include/linux/mmc/core.h linux-5.10.y-b/include/linux/mmc/core.h
--- linux-5.10.y-a/include/linux/mmc/core.h	2022-12-20 21:57:16.000000000 +0800
+++ linux-5.10.y-b/include/linux/mmc/core.h	2023-01-03 16:48:32.000000000 +0800
@@ -107,6 +107,9 @@
  */
 
 	unsigned int		busy_timeout;	/* busy detect timeout in ms */
+
+	bool			sanitize_busy;
+	
 	struct mmc_data		*data;		/* data segment associated with cmd */
 	struct mmc_request	*mrq;		/* associated request */
 };
Binary files linux-5.10.y-a/include/linux/mmc/._host.h and linux-5.10.y-b/include/linux/mmc/._host.h differ
Binary files linux-5.10.y-a/include/linux/mmc/._sdio.h and linux-5.10.y-b/include/linux/mmc/._sdio.h differ
diff -urN linux-5.10.y-a/include/linux/mmc/sdio.h linux-5.10.y-b/include/linux/mmc/sdio.h
--- linux-5.10.y-a/include/linux/mmc/sdio.h	2022-12-20 21:57:16.000000000 +0800
+++ linux-5.10.y-b/include/linux/mmc/sdio.h	2022-12-29 17:55:24.000000000 +0800
@@ -186,4 +186,7 @@
 
 #define SDIO_FBR_BLKSIZE	0x10	/* block size (2 bytes) */
 
+
+int sdio_reset_comm(struct mmc_card *card);
+
 #endif /* LINUX_MMC_SDIO_H */
diff -urN linux-5.10.y-a/include/linux/pwm.h linux-5.10.y-b/include/linux/pwm.h
--- linux-5.10.y-a/include/linux/pwm.h	2022-12-20 21:57:16.000000000 +0800
+++ linux-5.10.y-b/include/linux/pwm.h	2022-12-21 10:51:08.000000000 +0800
@@ -396,6 +396,7 @@
 			      enum pwm_polarity polarity);
 int pwmchip_add(struct pwm_chip *chip);
 int pwmchip_remove(struct pwm_chip *chip);
+int devm_pwmchip_add(struct device *dev, struct pwm_chip *chip);
 struct pwm_device *pwm_request_from_chip(struct pwm_chip *chip,
 					 unsigned int index,
 					 const char *label);
